<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F16%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F38.%20%E6%8A%A5%E6%95%B0%2F</url>
    <content type="text"><![CDATA[#一、题目原型： 报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：123456789101112131. 12. 113. 214. 12115. 1112211 被读作 &quot;one 1&quot; (&quot;一个一&quot;) , 即 11。11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。21 被读作 &quot;one 2&quot;, &quot;one 1&quot; （&quot;一个二&quot; , &quot;一个一&quot;) , 即 1211。给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。注意：整数顺序将表示为一个字符串。 #二、示例剖析：12345输入: 1输出: &quot;1&quot;输入: 4输出: &quot;1211&quot; 这题可能很多同学对于题目理解错了，我开始就是其中之一。我将它误认为是2位2位为一组，其实是错误的。再次分析题目后，我得到了正确的初步思路。1如果有相同的数字，count+1，直到有不同的数字，记录此时的count和当前数字，并将count重置为1 #三、解题思路：123456789/* 1 -&gt; 一个1 : 11 11 -&gt; 两个1 : 21 21 -&gt; 一个2一个1 : 12 11 1211 -&gt; 一个1 一个2 两个1 : 11 12 21 111221 -&gt; 三个1 两个2 一个1 : 31 22 11 312211 -&gt; 一个3 一个1 两个2 两个1 : 13112221 13112221 */ 如果有相同的数字，count+1，直到有不同的数字，记录此时的count和当前数字，并将count重置 #####第一种方法：字符串拼接优点：理解简单缺点：时间复杂度太高，循环嵌套较多1234567891011121314151617181920212223242526272829303132333435363738394041424344454647func countAndSay(_ n: Int) -&gt; String &#123; var nums: String = &quot;1&quot; if (n &lt; 6) &#123; if (n == 1) &#123; return &quot;1&quot; &#125;else if (n == 2) &#123; return &quot;11&quot; &#125;else if (n == 3) &#123; return &quot;21&quot; &#125;else if (n == 4) &#123; return &quot;1211&quot; &#125;else if (n == 5) &#123; return &quot;111221&quot; &#125; &#125;else &#123; var j: Int = 1 while j &lt; n &#123; var temp: String = &quot;&quot; var target: Int = Int(String.init(Array(nums)[0])) ?? 0 var count: Int = 1; var i: Int = 1 while i &lt; nums.count &#123; let int_num: Int = Int(String.init(Array(nums)[i])) ?? 0 // 利用 当前数字target 和 第i个数字int_num 进行比对 if (target != int_num) &#123; // 如果不同数字，此时需拼接数据，count重置为1。 temp.append(String.init(format: &quot;%d%d&quot;, count, target)) count = 1; target = int_num i = i + 1 &#125;else &#123; // 相同数字，count++，继续。 count = count + 1 i = i + 1 &#125; &#125; // 遍历完成，需要加上最后一组数据 temp.append(String.init(format: &quot;%d%d&quot;, count, target)) nums = temp; j = j + 1 &#125; &#125; return nums&#125; #####第二种办法：递归，利用数组存储进阶思路：既然我们知道了相同数字count+1，否则保存数据。而且下一条数据是通过上一条数据得到的。我们想到了递归。那么我们完全可以用数组将一组组数据保存起来，最后在拼接。12345678910111213141516171819202122232425262728293031323334353637383940// 递归// num：初始数组传[1]，之后传入的是haha()函数的返回值// index：初始化为0，之后++；作用：控制递归范围。// max：传入输入值nfunc get_hahaArr(_ num: [Int],_ index: Int,_ max: Int) &#123; if (index &lt; max - 1) &#123; get_hahaArr(haha(num), index+1, max) if (index == max - 2) &#123; num_ = haha(num) &#125; &#125;&#125;// 核心算法// 其实和上面第一种方法（拼接字符串）是一样的道理，只是表现方式不同。// 一个是拼接数字，一个是拼接数组里的元素。func haha(_ nums: [Int]) -&gt; [Int] &#123; var i: Int = 1 var count: Int = 1 var repeatArr: [Int] = [] // 将count和数字依次q存起来 while i &lt; nums.count &#123; if (nums[i-1] == nums[i]) &#123; count = count + 1 &#125;else &#123; repeatArr.append(count) repeatArr.append(nums[i-1]) count = 1 &#125; i = i + 1 &#125; repeatArr.append(count) repeatArr.append(nums[nums.count - 1]) // print(&quot;\(nums),\(repeatArr)&quot;) return repeatArr&#125; 12345678910111213141516171819// 最终的拼接// 通过n来取第几个数组var num_: [Int] = []func countAndSay(_ n: Int) -&gt; String &#123; guard (0&lt;n &amp;&amp; n &lt;= 30) else &#123; print(&quot;超出范围&quot;); return &quot;&quot; &#125; if (n == 1) &#123; return &quot;1&quot; &#125;else if (n &gt;= 2) &#123; get_hahaArr([1], 0, n) var str: String = &quot;&quot; for i in 0..&lt;num_.count &#123; str.append(&quot;\(num_[i])&quot;) &#125; return str &#125; return &quot;n需要是正整数&quot;&#125; 大家可以打开1234567```// countAndSay(6)[1],[1, 1][1, 1],[2, 1][2, 1],[1, 2, 1, 1][1, 2, 1, 1],[1, 1, 1, 2, 2, 1][1, 1, 1, 2, 2, 1],[3, 1, 2, 2, 1, 1] #四、小结1.耗时1844毫秒，内存消耗21.1M，超过5%的提交记录，总提交数18。2.耗时12毫秒，内存消耗20.7M，超过96.2%的提交记录，总提交数18。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo笔记之文章阅读时长和文章字数]]></title>
    <url>%2F2018%2F12%2F29%2FHexo%E7%AC%94%E8%AE%B0%2FHexo%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF%E5%92%8C%E6%96%87%E7%AB%A0%E5%AD%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[根目录下的_config.yml称为 站点配置文件， next目录下的_config.yml称为 主题配置文件。 Installation12$ npm install hexo-symbols-count-time --saveUsage 站点配置添加如下代码123456#文章字数、阅读时间 计算symbols_count_time: symbols: true time: true total_symbols: true total_time: true 主题配置找到symbols_count_time123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 效果]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo笔记之不蒜子统计]]></title>
    <url>%2F2018%2F12%2F28%2FHexo%E7%AC%94%E8%AE%B0%2FHexo%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%8D%E8%92%9C%E5%AD%90%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[将不蒜子打开其实在next中已经集成了不蒜子的统计，在官网上也说了。 在主题配置文件_config.yml下搜索busuanzi_count，enable设置为true 12345678busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: false post_views_icon: eye 设置在主题目录下layout/_third-party/analytics/找到busuanzi-counter.swig文件。 复制我下面的代码，将源代码替换掉。其实就是加了几个字，为了显得更直观些。 123456789101112131415161718192021222324&#123;% if theme.busuanzi_count.enable %&#125;&lt;div class=&quot;busuanzi-count&quot;&gt; &lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &#123;% if theme.busuanzi_count.total_visitors %&#125; &lt;span class=&quot;site-uv&quot; title=&quot;&#123;&#123; __(&apos;footer.total_visitors&apos;) &#125;&#125;&quot;&gt; 本站已有 &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; 位访客 &lt;i class=&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;&gt;&lt;/i&gt; &lt;/span&gt; &#123;% endif %&#125;&lt;span&gt; | &lt;/span&gt; &#123;% if theme.busuanzi_count.total_views %&#125; &lt;span class=&quot;site-pv&quot; title=&quot;&#123;&#123; __(&apos;footer.total_views&apos;) &#125;&#125;&quot;&gt; &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次阅读 &lt;i class=&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;&gt;&lt;/i&gt; &lt;/span&gt; &#123;% endif %&#125;&lt;/div&gt;&#123;% endif %&#125; 重新加载后，便可进行查看了，next默认将它放在底部。具体样式可以查看本博客底部。]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo笔记之Leancloud文章阅读次数统计]]></title>
    <url>%2F2018%2F12%2F28%2FHexo%E7%AC%94%E8%AE%B0%2FHexo%E7%AC%94%E8%AE%B0%E4%B9%8BLeancloud%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[站点根目录：就是你创建的blog文件夹目录，我的是daiyongtao.github.io。 主题目录：/theme/next。 注册Leancloud并创建应用 首先，前往Leancloud官网leancloud.cn进行注册，并登陆。 然后点击图示1处，进入控制台： 接着，点击图示1处，创建应用： 在弹出窗口1处输入应用名称（可随意输入，可更改，为演示方便取名为test），并选择2处“开发版”，然后点击3处创建： 到这里应用创建完成。 建立Counter类并在NexT中启用插件 点击1处应用名称进入应用管理界面： 如图，点击侧边栏1处创建Class： 在弹出窗口1处填入Counter，勾选2处无限制，并点击3处创建Class： 此时类已创建完成。接下来点击图示1处进入设置，然后点击2处进入应用Key： 粘贴App ID和App Key到NexT主题配置文件_config.yml对应位置。此时配置文件应如下： 1234leancloud_visitors: enable: true app_id: &lt;&lt;your app id&gt;&gt; app_key: &lt;&lt;your app key&gt;&gt; 设置Web安全域名确保域名调用安全。点击1处进入安全中心，然后在2处填写自己博客对应的域名（注意协议、域名和端口号需严格一致）： 到这里内容均与Doublemine的为NexT主题添加文章阅读量统计功能这篇文章相同，只不过截图为新版的Leancloud的界面。 部署云引擎以保证访客数量不被随意篡改 点击左侧1处云引擎，然后点击2处部署，再点击3处在线编辑： 点击1处创建函数： 在弹出窗口选择1处Hook类型，然后2处选择beforeUpdate，3处选择刚才建立的Counter类。在4中粘贴下方代码后，点5处保存。 12345678var query = new AV.Query(&quot;Counter&quot;);if (request.object.updatedKeys.indexOf(&apos;time&apos;) !== -1) &#123; return query.get(request.object.id).then(function (obj) &#123; if (obj.get(&quot;time&quot;) + 1 !== request.object.get(&quot;time&quot;)) &#123; throw new AV.Cloud.Error(&apos;Invalid update!&apos;); &#125; &#125;)&#125; 如图所示： 点击保存后应出现类似红框处函数。此时点击1处部署： 在弹出窗口点击1处部署： 等待出现红框处的成功部署信息后，点击1处关闭： 至此云引擎已成功部署，任何非法的访客数量更改请求都将失败。 进一步设置权限（可选，建议设置） 打开NexT主题配置文件_config.yml，将leancloud_visitors下的security设置为true（如没有则新增）： 1234567leancloud_visitors: enable: true app_id: &lt;&lt;your app id&gt;&gt; app_key: &lt;&lt;your app key&gt;&gt; # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security security: true betterPerformance: false 对betterPerformance选项的说明：由于Leancloud免费版的云引擎存在请求线程数和运行时间限制以及休眠机制，很多时候访客数量加载会很慢。如果设置betterPerformance为true，则网页则会在提交请求之前直接显示访客人数为查询到的人数+1，以增加用户体验。 打开博客配置文件_config.yml，新增以下配置： 123456leancloud_counter_security: enable_sync: true app_id: &lt;&lt;your app id&gt;&gt; app_key: &lt;&lt;your app key&gt; username: password: 打开cmd并切换至博客根目录，键入以下命令以安装hexo-leancloud-counter-security插件： 1npm install hexo-leancloud-counter-security --save 在相同目录键入以下命令： 1hexo lc-counter register &lt;&lt;username&gt;&gt; &lt;&lt;password&gt;&gt; 或 1hexo lc-counter r &lt;&lt;username&gt;&gt; &lt;&lt;password&gt;&gt; 将&lt;&lt;username&gt;&gt;和&lt;&lt;password&gt;&gt;替换为你自己的用户名和密码（不必与leancloud的账号）相同。此用户名和密码将在hexo部署时使用。 打开博客配置文件_config.yml，将&lt;&lt;username&gt;&gt;和&lt;&lt;password&gt;&gt;替换为你刚刚设置的用户名和密码： 123456leancloud_counter_security: enable_sync: true app_id: &lt;&lt;your app id&gt;&gt; app_key: &lt;&lt;your app key&gt; username: &lt;&lt;your username&gt;&gt; #如留空则将在部署时询问 password: &lt;&lt;your password&gt;&gt; #建议留空以保证安全性，如留空则将在部署时询问 在博客配置文件_config.yml的deploy下添加项： 123deploy: # other deployer - type: leancloud_counter_security_sync 返回Leancloud控制台的应用内。依次点击1 2，检查_User表中是否出现一条记录（图示以用户名为admin为例）： 点击1处进入Counter表，依次点击2 3，打开权限设置： 点击1add_fields后选择2指定用户， 并将下两栏留空：此处应与下条create设置相同（选择你所创建的用户）： 点击1create后选择2指定用户， 在3处键入用户名，点击4处后点击5处添加：完成此步操作后，界面应与图示类似： 点击1delete后选择2指定用户， 并将下两栏留空： 至此权限已设置完成，数据库记录只能在本地增删。每次运行hexo d部署的时候，插件都会扫描本地source/_posts下的文章并与数据库对比，然后在数据库创建没有录入数据库的文章记录。如果在博客配置文件中留空username或password，则在部署过程中程序会要求输入。 后记遇到的坑点⚠️，在博客配置文件_config.yml的deploy下添加项： 123deploy:# other deployer- type: leancloud_counter_security_sync 如果在配置- type: leancloud_counter_security_sync后hexo运行出现文件解析错误，了解一下YAML基础语法就行了。 错误样式： 123456deploy: type: git repo: https://github.com/daiyongtao/daiyongtao.github.io.git branch: master - type: leancloud_counter_security_sync 正确样式： 123456deploy:- type: git repo: https://github.com/daiyongtao/daiyongtao.github.io.git branch: master- type: leancloud_counter_security_sync repo: ⚠：在用hexo编写markdown时，会发现##根本没法使用，然后各种搜索发现了一个可行的办法，在#后面加上一个空格就行了😓 ⚠️：本文内容部分非原创，因特别详细且正确，所以就直接摘录了。 参考资料：Leancloud访客统计插件重大安全漏洞修复指南]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo笔记之评论和搜索]]></title>
    <url>%2F2018%2F12%2F28%2FHexo%E7%AC%94%E8%AE%B0%2FHexo%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%AF%84%E8%AE%BA%E5%92%8C%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[前言：其实next主题下已经集成了诸多第三方，我们只需要打开就能用了。 根目录下的_config.yml称为 站点配置文件， next目录下的_config.yml称为 主题配置文件。 评论系统我选择的是DISQUS。 注册DISQUS账号disqus官网 点击getstart，选择下面那个。 注册成功后，登录创建新的site。 注册成功后，创建新的site 获取shortname，绿色划线部分就是。 设置在主题配置找到DISQUS， 12345disqus: enable: true shortname: https-daiyongtao-github-io count: true lazyload: true 将它们都打开，shortname就写上面得到的那个。 重新部署上传后，就可以看到评论系统了。 搜索功能搜索就比较简单了，也是第三方。我选择的是local_search本地搜索。 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 重新部署上传后，就可以看到搜索功能了。]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo笔记之添加网易云音乐]]></title>
    <url>%2F2018%2F12%2F28%2FHexo%E7%AC%94%E8%AE%B0%2FHexo%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B7%BB%E5%8A%A0%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[站点根目录：就是你创建的blog文件夹目录，我的是daiyongtao.github.io。 主题目录：/theme/next。 生成外链 设置找到 主题目录下layout/_custom/sidebar.swig。 粘贴刚刚的那段html代码，如下所示 1234&lt;div id=&quot;music163player&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=450567505&amp;auto=1&amp;height=66&quot;&gt; &lt;/iframe&gt;&lt;/div&gt; hexo -g重新部署后，hero -server启动本地服务，打开http://localhost:4000/，在侧栏就能看到播放器了。]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo笔记之版权信息和打赏]]></title>
    <url>%2F2018%2F12%2F28%2FHexo%E7%AC%94%E8%AE%B0%2FHexo%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%89%88%E6%9D%83%E4%BF%A1%E6%81%AF%E5%92%8C%E6%89%93%E8%B5%8F%2F</url>
    <content type="text"><![CDATA[写之前备注：站点根目录：就是你创建的blog文件夹目录，我的是daiyongtao.github.io。 主题目录：/theme/next。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置； 另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 底部配置 注：大部分配置其实next都已经帮我们集成好了，我们只需要打开就行。 底部版权信息：第一步 主题目录：layout/_macro下，打开post.swig，找到 END POST BODY。not is_index 表示不在body索引列表区域。在它下面有很多底部工具。找到post-copyright 12345&#123;% if theme.creative_commons.license and theme.creative_commons.post and not is_index %&#125; &lt;div&gt; &#123;% include '../_partials/post/post-copyright.swig' with &#123; post: post &#125; %&#125; &lt;/div&gt;&#123;% endif %&#125; 读代码可知：creative_commons下的license 和 post都有值的时候，才会创建版权信息div标签。 第二步 复制creative_commons，打开主题配置文件，找到creative_commons所在位置。 可以看到如下信息。 1234creative_commons: license: by-nc-sa sidebar: false post: false 我们把post、sidebar打开，改成true。 至于license许可证，大家可以根据提示：Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero进行修改看结果。 第三步 主题目录：source/css/_custom 下打开custom.styl。 添加如下代码： 12345678// 版权信息.post-copyright &#123; margin: 2em 0 0; padding: 0.5em 1em; border-left: 3px solid #ff1700; background-color: #f9f9f9; list-style: none;&#125; 我们在这里设置了post_copyright的样式。 第四步 最后，hexo g &amp;&amp;hexo server之后，就可以在本地查看效果了。 主题目录：layout/_partials/post下，存放着底部版权信息post-copyright.swig。 如果需要自定义底部版权信息，只需要在post-copyright.swig进行修改即可，网上有很多例子，在这就不多说了。 打赏：打开主题配置文件，找到reward所在位置。 123456reward: enable: true comment: 坚持原创技术分享，您的支持将鼓励我继续创作！ wechatpay: /images/wechatpay.jpg # alipay: /images/alipay.jpg # bitcoin: /images/bitcoin.jpg 将enable打开，comment可以自己随便写，也可以按照我的模版。 下面是微信支付、支付宝支付、比特币三种支付方式，需要在主题目录下的source/images里添加你自己的二维码收款，就以上面的wechatpay.jpg等名字命名。我就只弄了微信的。]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[28. 实现strStr()]]></title>
    <url>%2F2018%2F09%2F28%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F28--%E5%AE%9E%E7%8E%B0strStr()%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 二、示例剖析：123456789 输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出: 2 输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出: -1说明:当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 三、解题思路：1.方法简单，运用swift语言特性1234567func strStr(_ haystack: String, _ needle: String) -&gt; Int &#123; if needle.count == 0 &#123; return 0 &#125; let range = haystack.range(of: needle) return range?.lowerBound.encodedOffset ?? -1&#125; 2.将字符串变成数组，进行遍历。(借鉴top1的方案，其实也简单，就是看起来代码貌似会比较多)1234567891011121314151617181920212223242526272829303132333435363738394041func strStr(_ haystack: String, _ needle: String) -&gt; Int &#123; let count1 = haystack.count let count2 = needle.count if count2 == 0 &#123; return 0 &#125; if count1 &lt; count2 &#123; return -1 &#125; var haystackChars = haystack.cString(using: .utf8)! var needleChars = needle.cString(using: .utf8)! var i = 0 var j = 0 let maxi = count1 - count2 let maxj = count2 - 1 while i &lt;= maxi &amp;&amp; j &lt;= maxj &#123; var m = i while m &lt;= count1 - 1 &amp;&amp; j &lt;= maxj &#123; let mv = haystackChars[m] let jv = needleChars[j] if mv == jv &#123; m += 1 j += 1 continue &#125; j = 0 i += 1 break &#125; &#125; j = j - 1 if j == maxj&#123; return i &#125; return -1&#125; 四、小结1.耗时856毫秒，超过32.58%的提交记录，总提交数74。2.耗时12毫秒，超过100%的提交记录，总提交数74。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[高铁爱情故事]]></title>
    <url>%2F2018%2F09%2F28%2F%E5%B0%8F%E6%95%85%E4%BA%8B%E4%BB%AC%2F%E9%AB%98%E9%93%81%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[夏阳满山- 高铁上邻座的女孩儿靠在我肩上睡着了，像只小猫一样蜷成一团，任长发铺在我的肩上。很奇妙的感觉，我静静坐着，一动不动，感受着这一切。谢谢你，让我假装有了两个小时的女朋友。 帐号已注销@夏阳满山-那天高铁上来一个男生，是我喜欢的类型，但是我不敢搭讪，生怕落花有意流水无情，然后我就假装睡着靠在了他的肩头，两个小时过去了，下一站我就要下车了，但他到底还是没有说话。 叮咚三下@帐号已注销那天高铁中途站上车，发现座位被一可爱的女孩儿坐了，此时女孩倚靠在一旁一猥琐男肩上睡着了，出于对女孩的保护，我坐到了猥琐男对面的座位，紧盯着他，在我正义的目光下猥琐男一直不敢有所动作，直到女孩安全下车，美丽的姑娘啊，出门在外，还是要注意安全哦😜 竟然还有后续： mpb233@叮咚三下记得那天是阴天，我刚交完手稿，准备坐高铁回家，刚上车，一个发如初春柳梢的女生坐在不远处，那一刻，左锁骨中线与第五肋间隙一阵阵的跳动，过了会，她好像累了，头忽然靠在了一个叔叔肩膀，那大概是她的父亲。在她的对面，一个老人家一直笑眯眯看着她，那大概是她爷爷，那十几分钟，仿佛过了一辈子 梅子果干醉解愁: @叮咚三下那天高铁上，坐在我斜对面的女生靠在我对面男生的肩上似乎是睡着了。女孩的嘴角微笑着却隐隐蹙着眉，似乎是在担心什么。但是他们的样子好甜蜜，我也想靠在旁边男生的肩上，但是我抬头看他，他却一直紧盯着对面的男生，我突然觉得心头一凉，世事弄人，我还是继续单着吧😔 故事的最后： 绝响卐可是高铁没有对面座位啊(๑•ี_เ•ี๑) – 网易云音乐 《鶯之緒》饭碗的彼岸 为什么网易云的朋友这么皮😒]]></content>
      <categories>
        <category>小故事们</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[书生与茶女]]></title>
    <url>%2F2018%2F09%2F28%2F%E5%B0%8F%E6%95%85%E4%BA%8B%E4%BB%AC%2F%E4%B9%A6%E7%94%9F%E4%B8%8E%E8%8C%B6%E5%A5%B3%2F</url>
    <content type="text"><![CDATA[“姑娘有心事？”书生抿嘴品茶问到。少女：”公子与城东唐公子可是熟识？”书生：”世交。”少女：”那下次你与他一起来吧。”书生：”他不喜品茶。”少女：”没关系，那他喜欢什么，我可以慢慢学。”书生：”我其实也不喜品茶。”少女：”说谎，那你每天早晨都跑我这茶铺干嘛。” – 网易云音乐 《红昭愿》音阙诗听 故事接着讲： 1. 书生：”品人。”姑娘：”何人？”书生：”姑娘你。小生不才，只见一面便已倾心于姑娘。”姑娘：”公子你…”姑娘：”可我早已倾心唐公子。”书生：”无妨，等姑娘不再倾心。”姑娘：”可能要许久许久。”书生：”我便等许久许久。” – 自&lt;知乎&gt;摘录改编 2. 少女：”没关系 那他喜欢什么 我可以慢慢学。”书生：”他喜欢我。”少女卒。 – 皮一下就很开心😂 3. “饮茶，无谓之喜之。只因…”书生停住不语，拿起茶杯，偏头望向窗外楼下。少女：”只因什么？”书生转回头看着少女，心里叹息一声，微微一笑。书生：”只因为，此处风景甚好啊。”少女：”此处风景甚好？仅此而已？”书生：”仅此而已。”书生：”那姑娘找城东唐公子又有何事？”少女：”唐公子与奴家是旧识，只是许久未见来我这茶坊，觉得奇怪”。书生：”唐公子恐怕以后都不会再来了”少女惊道：”为何？ “书生：”唐公子不日便会八抬大轿迎娶李家三小姐，想必此时正忙于筹备婚事”。少女：”李家三小姐，就是那个宛城首富李万金的三女儿？”书生：”不错。”少女：”倒也是门当户对。”“所以，以后只有我来此品茶了。”书生心里默想书生：”姑娘觉得，我与唐公子是否不同？”少女：”有何不同？”书生：”我只要一见倾心者，谁管什么门当户对！”少女：”公子！”…少女：”公子，你的茶凉了，我帮你再添一壶吧。” – 自&lt;百度贴吧&gt;摘录改编 后记：我们所企望的爱情，无非是我喜欢你，而你也刚好倾心于我。可是，现实中，总会有太多的不巧，太多的错过。所以，请珍惜现下拥有的美好，把握这属于你的幸福。😄祝好 愿伊人，喜乐安好。]]></content>
      <categories>
        <category>小故事们</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[125. 验证回文串]]></title>
    <url>%2F2018%2F09%2F27%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F125--%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。说明：本题中，我们将空字符串定义为有效的回文串。 二、示例剖析：1234567示例 1:输入: &quot;A man, a plan, a canal: Panama&quot;输出: true示例 2:输入: &quot;race a car&quot;输出: false 三、解题思路：回文串：就是从左边数到右边，和从右边数到左边是一样的。比如：ama题目中说1234```abcdefghijklmnopqrstuvwxyz 97~122 小写字母ABCDEFGHIJKLMNOPQRSTUVWXYZ 65~90 大写字母0123456789 48~57 数字 所以我们只需要判定这一些字符的ASCII码12345678910111213141516171819202122232425262728293031323334func isPalindrome(_ s: String) -&gt; Bool &#123; if s.count == 0 &#123; return true &#125; var chars = s.cString(using: String.Encoding.utf8) let count = (chars?.count)! var mutChars: [Int8] = [] for i in 0..&lt;count &#123; if chars![i] &gt;= 97 &amp;&amp; chars![i] &lt;= 122 &#123; mutChars.append(chars![i]) &#125;else if chars![i] &gt;= 65 &amp;&amp; chars![i] &lt;= 90 &#123; // 将大写字母 转小写 chars![i] = chars![i] + 32 mutChars.append(chars![i]) &#125;else if chars![i] &gt;= 48 &amp;&amp; chars![i] &lt;= 57 &#123; mutChars.append(chars![i]) &#125; &#125; let mutCount = mutChars.count var revert_mutChars: [Int8] = Array.init(repeating: 0, count: mutCount) for i in 0..&lt;mutCount &#123; revert_mutChars[i] = mutChars[mutCount - 1 - i] &#125; if revert_mutChars == mutChars &#123; return true &#125; return false&#125; 四、小结1.耗时44毫秒，超过78.57%的提交记录，总提交数476。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[242. 有效的字母异位词]]></title>
    <url>%2F2018%2F09%2F27%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F242--%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 二、示例剖析：12345678910111213示例 1:输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true示例 2:输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false说明:你可以假设字符串只包含小写字母。进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 三、解题思路：1.第一想到的就是排下序，然后比对。 123456789func isAnagram(_ s: String, _ t: String) -&gt; Bool &#123; if s.count != t.count &#123; return false &#125; if s.sorted() == t.sorted() &#123; return true &#125; return false&#125; 2.用ASCII码12345678910111213141516171819202122232425262728func isAnagram(_ s: String, _ t: String) -&gt; Bool &#123; if s.count != t.count &#123; return false &#125; var counter_s = Array.init(repeating: 0, count: 26) var counter_t = Array.init(repeating: 0, count: 26) var char_s = s.cString(using: String.Encoding.utf8) var char_t = t.cString(using: String.Encoding.utf8) // 因为.cString方法默认会在末尾加上空字符，ASCII码为0 // 所以需要将其删除 char_s?.removeLast() char_t?.removeLast() for char in char_s! &#123; let index = Int(char - 97) counter_s[index] += 1 &#125; for char in char_t! &#123; let index = Int(char - 97) counter_t[index] += 1 &#125; print(char_s,char_t) return counter_s == counter_t&#125; 3.用ASCII码，.unicodeScalars方法，省去了删除最后的空字符的操作12345678910111213141516171819func isAnagram(_ s: String, _ t: String) -&gt; Bool &#123; if s.count != t.count &#123; return false &#125; var counter_s = Array.init(repeating: 0, count: 26) var char_s = s.unicodeScalars for char in char_s &#123; let index = Int(char.value - 97) counter_s[index] += 1 &#125; var counter_t = Array.init(repeating: 0, count: 26) var char_t = t.unicodeScalars for char in char_t &#123; let index = Int(char.value - 97) counter_t[index] += 1 &#125; print(char_s,char_t) return counter_s == counter_t&#125; 四、小结1.耗时524毫秒，超过16.13%的提交记录，总提交数34。2.耗时148毫秒，超过70.97%的提交记录，总提交数34。3.耗时 44 毫秒，超过93.55%的提交记录，总提交数34。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[387. 字符串中的第一个唯一字符]]></title>
    <url>%2F2018%2F09%2F26%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F387--%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。注意事项：您可以假定该字符串只包含小写字母。 二、示例剖析：12345s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2. 三、解题思路：用ASCII码来判断，因为一个字符对应唯一的一个ASCII码。由于题目可以假定只包含小写字母，我们范围就可缩小至小写字母这一块：97~122。用一个count=27的数组，所有元素初始化都为0。如果ASCII码出现一次，该元素就+1；如果重复出现多次，该元素就会&gt;1。所以我们只需要拿到最后的==1的元素就行。取它的i值。12let allLowerLetters: [Int8]? = &quot;abcdefghijklmnopqrstuvwxyz&quot;.cString(using: String.Encoding.utf8)// 小写字母ASCII码为：97~122 12345678910111213141516171819202122232425func firstUniqChar(_ s: String) -&gt; Int &#123; // 1.先将字符串转换成ASCII码数组 let chars: [Int8]? = s.cString(using: String.Encoding.utf8) var ret: Int = -1 var last: [Int] = Array.init(repeating: 0, count: 27) if s.count &gt; 0 &#123; for i in 0..&lt;s.count &#123; let hash_i: Int = Int(chars![i]) let hash_a: Int = 97 last[hash_i - hash_a] = last[hash_i - hash_a] + 1 &#125; for i in 0..&lt;s.count &#123; let hash_i: Int = Int(chars![i]) let hash_a: Int = 97 if last[hash_i - hash_a] == 1 &#123; ret = i break &#125; &#125; &#125; return ret&#125; 四、小结1.耗时188毫秒，超过96.94%的提交记录，总提交数104。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[344. 反转字符串]]></title>
    <url>%2F2018%2F09%2F25%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F344--%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[一、题目原型： 编写一个函数，其作用是将输入的字符串反转过来。 二、示例剖析：1234567示例 1:输入: &quot;hello&quot;输出: &quot;olleh&quot;示例 2:输入: &quot;A man, a plan, a canal: Panama&quot;输出: &quot;amanaP :lanac a ,nalp a ,nam A&quot; 三、解题思路：1.用一个数组存起来，再反向遍历。12345678910111213func reverseString(_ s: String) -&gt; String &#123; var chars: [Character] = [] for char in s &#123; chars.append(char) &#125; var string: String = &quot;&quot; var index = s.count - 1 while index &gt;= 0 &#123; string.append(chars[index]) index = index - 1 &#125; return string&#125; 2.用一个数组接收字符串，直接利用原数组进行反转。12345678910111213141516171819func reverseString(_ s: String) -&gt; String &#123; var chars = s.cString(using: String.Encoding.utf8)! var left = 0 var right = s.count - 1 while left &lt; right &#123; let char = chars[left] chars[left] = chars[right] chars[right] = char left = left + 1 right = right - 1 &#125; print(chars) return String.init(utf8String: chars)!&#125; 四、小结1.耗时60毫秒，超过48%的提交记录，总提交数476。2.耗时36毫秒，超过99.33%的提交记录，总提交数476。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[326. 3的幂]]></title>
    <url>%2F2018%2F09%2F25%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F326--3%E7%9A%84%E5%B9%82%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个整数，写一个函数来判断它是否是 3 的幂次方。 二、示例剖析：1234567891011输入: 27输出: true输入: 0输出: false输入: 9输出: true输入: 45输出: false 三、解题思路：除以3，然后判断%3是否=0 12345678910111213141516171819func isPowerOfThree(_ n: Int) -&gt; Bool &#123; if n &lt; 3 &#123; if n == 1 &#123; return true &#125; return false &#125; var mut_n = n while mut_n &gt; 0 &#123; if mut_n % 3 != 0 &amp;&amp; mut_n != 1 &#123; print(mut_n) return false &#125; mut_n = mut_n / 3 &#125; return true&#125; 四、小结耗时```毫秒，超过```30%```的提交记录，总提交数```21038 ```。123456----------------&gt;进阶：你能不使用循环或者递归来完成本题吗？思路：在Int有效范围内找出最大的3的幂次方的数b，只要n是3的幂次方，那么n必定能被b整除。 func isPowerOfThree(_ n: Int) -&gt; Bool { if n &lt;= 0 { return false } // 将整数转换为浮点型 let max = Double(Int.max) // 求出Int范围内最大的3的幂 -- 39 let k = Int(log(max) / log(3.0)) // 得到Int范围内最大的3的幂次方，幂=k let b: Int = Int(pow(3.0, Double(k))) // 如果n是3的幂次方，那么b必定能整除n return b % n == 0 }12345678然而，问题出来了，leetcode输入27，竟然是错的！！！后面发现，原来是精确度的问题。&gt;float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为```6~7```位有效数字； &gt;double：2^52 = 4503599627370496，一共16位，同理，double的精度为```15~16```位；&gt; decimal：1-10^38 ~ 10^38-1 的固定精度和小数位的数字，精度为```28~29```位有效数字； // pow(3.0, 39.0)所得结果Float： 4052555218645155840Double： 4052555153018976256Decimal: 405255515301897626712明显是Double的精度不够了，算出的结果精度要求为```18```位。所以我把Double换成了Decimal。 func isPowerOfThree(_ n: Int) -&gt; Bool { if n &lt;= 0 { return false } // 将整数转换为浮点型 let max = Double(Int.max) // 求出Int范围内最大的3的幂 -- 39 let k: Int = Int(log(max) / log(3.0)) // 得到Int范围内最大的3的幂次方，幂=k let x: Decimal = Decimal.init(3) let b: Int = Int(pow(x, k).description)! // 如果n是3的幂次方，那么b必定能整除n return int_b % n == 0 }12然后，报错了。。。😭```cannot invoke &apos;pow&apos; with an argument list of type &apos;(Decimal, Int)&apos; leetcode编译板竟然编译不通过，说类型不对。苹果上写的是有这个类型的。12// 苹果官方文档public func pow(_ x: Decimal, _ y: Int) -&gt; Decimal 算了，懒得去搞那个类型了。我发现，直接把正确的数据填上去不就完了吗最终代码，超简易。123456789func isPowerOfThree(_ n: Int) -&gt; Bool &#123; if n &lt;= 0 &#123; return false &#125; let b: Int = 4052555153018976267 return b % n == 0&#125; 小结耗时244毫秒，超过97.5%的提交记录，总提交数21038。完美😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[204.计算质数]]></title>
    <url>%2F2018%2F09%2F21%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F204-%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、题目原型： 统计所有小于非负整数 n 的质数的数量。 二、示例剖析：123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。（不包括10） 三、解题思路： 注意：题意是 所有小于n的数字里，质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。也就是只能被1和自己整除的数。 首先看一个关于质数分布的规律：大于等于5的质数一定和6的倍数相邻。例如 （5和7）（11和13）（17和19）等等；证明：令x≥1，将大于等于5的自然数表示如下：··· 6x-1，6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ···可以看到，不在6的倍数两侧，即6x两侧的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，再除去6x本身，显然，素数要出现只可能出现在6x的相邻两侧。因此在5到sqrt(n)中每6个数只判断2个，时间复杂度O(sqrt(n)/3)。 12345678910111213141516171819202122// 判断一个数字是否为质数func isPrime(_ num: Int) -&gt; Bool &#123; if num%6 != 1 &amp;&amp; num%6 != 5 &#123; //不是质数 return false &#125; let num_sqrt = sqrt(Double(num)) let n = Int(num_sqrt) + 1 var index: Int = 5 if n &gt;= 5 &#123; while index &lt;= n &#123; if num % index == 0 || num % (index+2) == 0 &#123; //不是质数 return false &#125; index = index + 6 &#125; &#125; return true&#125; 1234567891011121314151617181920#func countPrimes(_ n: Int) -&gt; Int &#123; var count: Int = 0 if n == 1 || n == 2 &#123; return 0 &#125;else if n == 3 &#123; return 1 &#125;else if n == 4 || n == 5 &#123; return 2 &#125;else if n == 6 || n == 7 &#123; return 3 &#125;else if n &gt; 7 &#123; for i in 7..&lt;n &#123; count = 3 if self.isPrime(i) &#123; count = count + 1 &#125; &#125; &#125; return count&#125; 四、小结耗时1524毫秒，超过45.16%的提交记录，总提交数20。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[412. Fizz Buzz]]></title>
    <url>%2F2018%2F09%2F21%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F412--Fizz-Buzz%2F</url>
    <content type="text"><![CDATA[一、题目原型： 写一个程序，输出从 1 到 n 数字的字符串表示。 如果 n 是3的倍数，输出“Fizz”； 如果 n 是5的倍数，输出“Buzz”； 如果 n 同时是3和5的倍数，输出 “FizzBuzz”。 二、示例剖析：1234n = 15,返回:[&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;7&quot;,&quot;8&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;11&quot;,&quot;Fizz&quot;,&quot;13&quot;,&quot;14&quot;,&quot;FizzBuzz&quot;] 三、解题思路：这题非常简单，就是从0遍历到n-1，把对应的数字换成字符串。12345678910111213141516171819202122// 公倍数func fizzBuzz(_ n: Int) -&gt; [String] &#123; var strings: [String] = [] for i in 0..&lt;n &#123; if (i + 1) % 15 == 0 &#123; strings.append(&quot;FizzBuzz&quot;) &#125;else &#123; if (i + 1) % 3 == 0 &#123; strings.append(&quot;Fizz&quot;) &#125; else if (i + 1) % 5 == 0 &#123; strings.append(&quot;Buzz&quot;) &#125; else &#123; strings.append(&quot;\(i+1)&quot;) &#125; &#125; &#125; return strings&#125; 四、小结耗时20毫秒，超过100%的提交记录，总提交数8。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[48. 旋转图像]]></title>
    <url>%2F2018%2F09%2F21%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F48--%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。 说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 二、示例剖析：12345678910111213141516171819202122232425262728示例 1:给定 matrix =[[1,2,3],[4,5,6],[7,8,9]],原地旋转输入矩阵，使其变为:[[7,4,1],[8,5,2],[9,6,3]]示例 2:给定 matrix =[[ 5, 1, 9,11],[ 2, 4, 8,10],[13, 3, 6, 7],[15,14,12,16]],原地旋转输入矩阵，使其变为:[[15,13, 2, 5],[14, 3, 4, 1],[12, 6, 8, 9],[16, 7,10,11]] 三、解题思路：原题题意，我们把n*n的数组想象成一个正方形，我们顺时针旋转正方形的时候，最后得到的就是旋转后的新数组。乍一看很简单，因为有很多规律可以找到。比方说示例1，第一行123，变成了新数组的最后一列；第二行456，变成了新数组的倒数第二列；第三行789，变成了新数组的第一列。我们完全可以用一个临时数组将每一行抽取出来，再根据该规律，加入到新数组中。 123456![推算笔记](http://dancheclassmate.cn/2018/09/21/leetCode题库笔记/48--旋转图像/推算笔记.png)然后发现，全乱了。。。问题原因应该是在相互赋值时，i和j的遍历会重复，反正方法是不对的。接下来我想，既然一步完成不了，就分几步来做吧。1.```上下置换```，将最上面的一排放到最下面，第二排放到倒数第二排。 [ [1,2,3], [4,5,6], [7,8,9]], 变成 [ [7,8,9], [4,5,6], [1,2,3]],12 var i: Int = 0var j: Int = 0let m = matrix.countlet n = matrix[0].countwhile j &lt; n { while i &lt; m/2 { let temp = matrix[i][j] matrix[i][j] = matrix[m-1-i][j] matrix[m-1-i][j] = temp i = i + 1 } j = j + 1 i = 0 }print(“i = (i) j = (j) (matrix)”)12.根据中间的753这条斜线对称。 [ [7,8,9], [4,5,6], [1,2,3]], 变成 [ [7,4,1], [8,5,2], [9,6,3]],12345678910111213141516```i = 0j = 0while j &lt; n - 1 &#123; while i &lt; m &#123; if (i &gt;= j) &#123; let temp = matrix[i][j] matrix[i][j] = matrix[j][i] matrix[j][i] = temp print(&quot;i = \(i) j = \(j) \(matrix)&quot;) &#125; i = i + 1 &#125; j = j + 1 i = 0&#125; 四、小结耗时72毫秒，超过73.77%的提交记录，总提交数504。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[36. 有效的数独]]></title>
    <url>%2F2018%2F09%2F21%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F36--%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[一、题目原型： 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 二、题目意思剖析：12345678910111213输入:[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 三、解题思路：数独，应该大家都玩过，其实就只是判断三个点，横、竖、3*3的方格。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798func isValidSudoku(_ board: [[Character]]) -&gt; Bool &#123; var bool: Bool = true for i in 0..&lt;board.count &#123; let characters = board[i] var mutCharacters1: [Character] = [] var mutCharacters2: [Character] = [] for j in 0..&lt;characters.count &#123; // 1.每行比较 let character1 = board[i][j] if character1 != &quot;.&quot; &#123; mutCharacters1.append(character1) &#125; // 2.每列比较 let character2 = board[j][i] if character2 != &quot;.&quot; &#123; mutCharacters2.append(character2) &#125; if j == characters.count - 1 &#123; let set1: Set = Set(mutCharacters1) if set1.count == mutCharacters1.count &#123; bool = true &#125;else &#123; bool = false return bool &#125; let set2: Set = Set(mutCharacters2) if set2.count == mutCharacters2.count &#123; bool = true &#125;else &#123; bool = false return bool &#125; &#125; &#125; &#125; var index_i = 0 var index_j = 0 while index_i&lt;board.count &#123; // 3.每方格 while index_j&lt;board[0].count &#123; var square: [Character] = [] if board[index_i][index_j] != &quot;.&quot; &#123; square.append(board[index_i][index_j]) &#125; if board[index_i+1][index_j] != &quot;.&quot; &#123; square.append(board[index_i+1][index_j]) &#125; if board[index_i+2][index_j] != &quot;.&quot; &#123; square.append(board[index_i+2][index_j]) &#125; if board[index_i][index_j+1] != &quot;.&quot; &#123; square.append(board[index_i][index_j+1]) &#125; if board[index_i+1][index_j+1] != &quot;.&quot; &#123; square.append(board[index_i+1][index_j+1]) &#125; if board[index_i+2][index_j+1] != &quot;.&quot; &#123; square.append(board[index_i+2][index_j+1]) &#125; if board[index_i][index_j+2] != &quot;.&quot; &#123; square.append(board[index_i][index_j+2]) &#125; if board[index_i+1][index_j+2] != &quot;.&quot; &#123; square.append(board[index_i+1][index_j+2]) &#125; if board[index_i+2][index_j+2] != &quot;.&quot; &#123; square.append(board[index_i+2][index_j+2]) &#125; if index_j % 3 == 0 &#123; let set: Set = Set(square) if set.count == square.count &#123; bool = true &#125;else &#123; bool = false return bool &#125; &#125; // 因为是3*3的小方格，所以需要+3，而不是再+1了 index_j = index_j + 3 &#125; index_i = index_i + 3 // 因为index_j循环后变成了9，需要设置为0 index_j = 0 &#125; return bool&#125; 四、小结耗时72毫秒，超过73.77%的提交记录，总提交数504。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[283. 移动零]]></title>
    <url>%2F2018%2F09%2F21%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F283--%E7%A7%BB%E5%8A%A8%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 二、题目意思剖析：123456示例:输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明:必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。 三、解题思路：遍历数组，如果发现元素=0，直接删除当前元素，在数组末尾加上01234[0,1,0,3,12][1,0,3,12,0][1,3,12,0,0][1,3,12,0,0] 123456789101112131415161718192021func moveZeroes(_ nums: inout [Int]) &#123; if nums.count == 1 &#123; return &#125; var i: Int = 0 var j: Int = 0 let n: Int = nums.count while i&lt;n &amp;&amp; j&lt;n &#123; if nums[i] == 0 &#123; print(&quot;\(i)开始\(nums)&quot;) nums.remove(at: i) print(&quot;\(i)删除\(nums)&quot;) nums.append(0) print(&quot;\(i)添加\(nums)&quot;) &#125;else &#123; i = i + 1 &#125; j = j + 1 &#125;&#125; 四、小结耗时32毫秒，超过59.06%的提交记录，总提交数21。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[66.加一]]></title>
    <url>%2F2018%2F09%2F20%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F66-%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。 二、题目意思剖析：123456789示例 1:输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。示例 2:输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 三、解题思路：误区：我一开始的想法是把数字+1，然后再分。但是题目的数字并没有限制，所以，当去取余数然后*10的多少次方时，就越界了崩溃了。所以，这题不能这么做。 ######正解：递归，只能通过递归来算。其实我们考虑该题的核心，应该集中于一点：1231.在这里我们先要将最后一位先判断，是否+1后=10。如果=10，就需要进一位，再去判断接下来的情况；如果&lt;10,那就直接返回原数组了。2.至于除了最后一位的情况，其实也是和前面一样判断。3.问题核心：```iscarry：是否需要进位，也就是前一位+1后是否等于10 1234567891011121314151617181920212223242526272829303132333435363738394041// 递归 iscarry：是否进位，也就是他前一个数是不是等于10func isCarry(_ index: inout Int, _ digits: inout [Int], _ iscarry: Bool) -&gt; [Int] &#123; if index &lt; 0 &#123; if iscarry &#123; // 如果这个时候数组已经遍历完了，但是iscarry=true，说明还是进位，在最前面加一个1 digits.insert(1, at: 0) &#125; return digits &#125; var bool: Bool = true if index == digits.count - 1 &#123; let num = digits[index] + 1 if num == 10 &#123; digits[index] = 0 bool = true &#125;else &#123; digits[index] = num bool = false return digits &#125; &#125;else &#123; var num: Int = 0 if iscarry &#123; //如果是进位 num = digits[index] + 1 if num == 10 &#123; digits[index] = 0 bool = true &#125;else &#123; digits[index] = num bool = false return digits &#125; &#125; &#125; index = index - 1 return isCarry(&amp;index, &amp;digits, bool)&#125; 12345678func plusOne(_ digits: [Int]) -&gt; [Int] &#123; var nums: [Int] = digits // 默认 index = 最后一位 var index: Int = digits.count-1 return isCarry(&amp;index, &amp;nums, false)&#125; 四、小结耗时16毫秒，超过77.09%的提交记录，总提交数109。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[350. 两个数组的交集 II]]></title>
    <url>%2F2018%2F09%2F20%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F350--%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-II%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定两个数组，编写一个函数来计算它们的交集。 二、题目意思剖析：1234567示例 1:输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2:输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 三、解题思路：1.遍历两个数组，如果发现有元素相同，就用新数组把它存起来。然后，把原来的两个数组里的这个元素设置为Int.max，下一次遍历就不会重复了。耗时12 func intersect(_ nums1: [Int], _ nums2: [Int]) -&gt; [Int] { if nums1.count == 0 || nums2.count == 0 { return [] } var nums: [Int] = [] var mutNums1 = nums1 var mutNums2 = nums2 for i in 0..&lt;mutNums1.count { let subNum1: Int = mutNums1[i] for j in 0..&lt;mutNums2.count { let subNum2: Int = mutNums2[j] if (subNum1 == subNum2) { nums.append(subNum1) mutNums1[i] = Int.max mutNums2[j] = Int.max break } } } return nums }`]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[217. 存在重复元素]]></title>
    <url>%2F2018%2F09%2F20%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F217--%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 二、题目意思剖析：1234567891011示例 1:输入: [1,2,3,1]输出: true示例 2:输入: [1,2,3,4]输出: false示例 3:输入: [1,1,1,3,3,4,3,2,4,2]输出: true 三、解题思路：1.先排序，然后通过两个指针进行遍历比较，相同就直接返回true。耗时12 func containsDuplicate(_ nums: [Int]) -&gt; Bool { var mutNums: [Int] = nums.sorted() let count = mutNums.count var i: Int = 0 var j: Int = 1 while i&lt;j &amp;&amp; i&lt;count &amp;&amp; j&lt;count { if mutNums[i] == mutNums[j] { return true }else { i = i + 1 j = j + 1 } } return false }12345672.直接用set来判断，因为set是无重复数据的集合。耗时```60```毫秒，超过```72.22%```的提交记录。&gt;Swift语言 提供Arrays、Sets和Dictionaries三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。 func containsDuplicate(_ nums: [Int]) -&gt; Bool { let set = Set(nums) return set.count &lt; nums.count}1233.用Set的另一个方法，.inserted，如果集合里存在某个元素，再加该元素时，.inserted = false。耗时```48```毫秒，超过```98.33%```的提交记录。 // checkNums ：[1] [1,2] [1,2,3] [1,2,3,4]// 因为集合里有3，所以加不进去，所以.inserted = false，说明有重复的数字func containsDuplicate(_ nums: [Int]) -&gt; Bool { if nums.count &lt;= 1 { return false} var checkNums: Set = [nums.first!] for i in 1..&lt;nums.count { if !checkNums.insert(nums[i]).inserted { return true } } return false}` 四、小结推荐使用2、3方法，总提交数18.]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[136. 只出现一次的数字]]></title>
    <url>%2F2018%2F09%2F14%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F136--%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素 二、题目意思剖析：123456789说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例 1:输入: [2,2,1]输出: 1示例 2:输入: [4,1,2,1,2]输出: 4 三、解题思路：第一种根据题目意思，数组的个数一定是奇数。(2+2+2+1+2)类似这样,先排个序，然后 i = i + 2，一旦前后不同，就return前面那个数字。12345678910111213141516171819202122232425func singleNumber(_ nums: [Int]) -&gt; Int &#123; if nums.count == 1 &#123; return nums.first! &#125; // 0 0 1 1 2 3 3 // 除了某个元素只出现一次以外，其余每个元素均出现两次 // 说明数组个数一定是奇数 var mutnums = nums.sorted() var index: Int = 0 while index &lt; mutnums.count &#123; //print(index) if index+1 &gt;= mutnums.count &#123; return mutnums[index] &#125; //上面代码已经屏蔽掉了index+1越界的情况 if mutnums[index] != mutnums[index+1] &#123; return mutnums[index] &#125; index = index + 2 &#125; //print(mutnums) return -1&#125; 第二种：异或法找到数组里唯一不同的那个数字，其实可以用1两个相同数字 异或所得到的是0，可以测试下。 { var temp: Int = 2 temp ^= 2 print(temp)}打印的temp = 010异或任何数字，都等于原数字本身 { var temp: Int = 0 temp ^= 2 print(temp)}打印的temp = 2123456789101112131415161718######原理：假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：A = 0011 1100B = 0000 1101A&amp;B = 0000 1100A|B = 0011 1101A^B = 0011 0001~A = 1100 0011&gt;&amp; 两者同时为真才为真；| 两者一者为真就为真；^相同为假，不同为真所以，我们只要用0去异或数组里所有的数字，最后得到的就是不同的那个数字。 func singleNumber(_ nums: [Int]) -&gt; Int { if nums.count == 1 { return nums.first! } // 异或 var temp: Int = 0 for num in nums { temp ^= num } return temp}` 四、小结第一种方法耗时 144ms，超过19.02%提交记录。第二种方法耗时 32ms，超过68.1%提交记录。总提交数：16。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《名侦探柯南》灰原哀]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%89%8B%E7%BB%98%2F%E3%80%8A%E5%90%8D%E4%BE%A6%E6%8E%A2%E6%9F%AF%E5%8D%97%E3%80%8B%E7%81%B0%E5%8E%9F%E5%93%80%2F</url>
    <content type="text"><![CDATA[画友评价：头发线条不清晰，结构布局有些不对，眼睛间距太宽。]]></content>
      <categories>
        <category>涂鸦</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《一人之下》王也]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%89%8B%E7%BB%98%2F%E3%80%8A%E4%B8%80%E4%BA%BA%E4%B9%8B%E4%B8%8B%E3%80%8B%E7%8E%8B%E4%B9%9F%2F</url>
    <content type="text"><![CDATA[《一人之下》第一季豆瓣评分8.6，第二季豆瓣评分9.2，可以去看看。里面最有灵性也最神秘的角色当属武当王道长。 画友评价：眼睛太大，右边脸太小了，脖子太长。。。]]></content>
      <categories>
        <category>涂鸦</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[128.旋转数组]]></title>
    <url>%2F2018%2F09%2F11%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F128-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的原地算法。 二、题目意思剖析：1234567891011121314示例 1:输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]示例 2:输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释:向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 三、解题思路：1.最后一个数字 - &gt; 第一个2.最后一个数字 - &gt; 第一个。。。1234567891011121314151617181920func rotate(_ nums: inout [Int], _ k: Int) &#123; if nums.count == 0 &#123; return &#125; var mutNums: [Int] = [] var mut_k: Int = k while mut_k &gt; 0 &#123; mutNums.append(nums.last!) for i in 0..&lt;nums.count-1 &#123; mutNums.append(nums[i]) &#125; nums = mutNums mutNums = [] mut_k = mut_k - 1 &#125; print(nums)&#125; 。。。待续]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[122.买卖股票的最佳时机 II]]></title>
    <url>%2F2018%2F09%2F11%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 二、题目意思剖析：1234567891011121314151617示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 三、解题思路：将前后两天价格相减，盈利interest = prices[i+1] - prices[i]用一个新数组，将所有正整数加起来就是答案。(方便理解)或者更简单，不用弄新的数组，得到interest后，直接判断是否为正数，如果是就加起来，最后的和就是结果。 123456789[7,1,5,7,9,4] 9 - 1 = 8[-6,4,2,2,-2] [1,7,5,3,6,4] 7 - 1 = 6 6 - 3 = 3 6 + 3 = 9[6,-2,-2,3,-2] 12345678910111213141516func maxProfit(_ prices: [Int]) -&gt; Int &#123; if prices.count == 0 &#123; return 0 &#125; var result_interest: Int = 0 for i in 0..&lt;prices.count-1 &#123; let interest: Int = prices[i+1] - prices[i] if interest &gt; 0 &#123; result_interest = result_interest + interest &#125; &#125; return result_interest&#125; 四、小结耗时28毫秒，超过33.94%的提交记录，总提交数201。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《项脊轩志》后续]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%B0%8F%E6%95%85%E4%BA%8B%E4%BB%AC%2F%E3%80%8A%E9%A1%B9%E8%84%8A%E8%BD%A9%E5%BF%97%E3%80%8B%E5%90%8E%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[前言：《项脊轩志》– 高中课文，全文背诵（我们那时候）。明代文学家归有光所作的一篇回忆性记事散文，全文真切再现了祖母、母亲、妻子的音容笑貌，也表达了作者对于三位已故亲人的深沉怀念。 其实《项脊轩志》归有光自己就分了两部分来写。前四段写于明世宗嘉靖三年（1524年），当时归有光18岁。在经历了结婚、妻死、不遇等人生变故后，之后作者于明世宗嘉靖十八年（1539年），又为这篇散文增添了补记。（后半段写得着实悲伤） 今天想说的是它的最后一句： 庭有枇杷树，吾妻死之年所手植也，今已亭亭如盖矣。 人们不愿故事太过悲伤，然后《项脊轩志》有了后续。 今伐之，为博小娘子一笑。 1.起手网友很皮。 小娘子一笑，恰似吾妻少年时。 2.接的好，我们要把故事从头讲 小娘子为吾与吾妻之女，今伐树，为小娘子造出嫁之物，愿其伉俪情深，不输吾与吾妻。 3.我们所有人都期待白首不负心，这是我们最爱的结局。 注：归有光：明代“唐宋派”代表作家，被誉为“今之欧阳修。” 小娘子：少女的通称。宋欧阳修《答连郎中》“承贤郎，小娘子见过。故人有佳儿女，朋友当所共庆也。”归有光有“今之欧阳修”之称，“小娘子”用于此恰当无比。 在文中，我把“年少”改为“少年”，在古时候，未出嫁的女子、男子他们所处的时期都可称为少年时。特别爱“少年”两个字，可能是最纯洁的年代吧，也可能是自己再也回不去了。 抛开项脊轩志这篇文章，光从最后这些句子，我感觉都能编很长的一段故事了。 大风吹来了我们随风飘荡在风尘中遗忘的清白脸庞此生多寒凉此身越重洋轻描时光漫长低唱语焉不详大风吹来了我们随风飘荡在风尘中熄灭的清澈目光我想回头望把故事从头讲时光迟暮不返人生已不再来]]></content>
      <categories>
        <category>小故事们</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[26.从排序数组中删除重复项]]></title>
    <url>%2F2018%2F09%2F10%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F26.%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[前言：从20题之后就没再按照顺序来做了，准备先把初级算法先写完。 一、题目原型： 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 二、题目意思剖析：12345678910111213141516171819给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) &#123; print(nums[i]); &#125; 三、解题思路：想到的第一种办法是用两个变量来分别控制，resultCount：数组最终元素个数，n：和i两个指针间，形成一个滑动窗口关系。1234567891011121314151617181920212223242526func removeDuplicates(_ nums: inout [Int]) -&gt; Int &#123; if nums.count == 0 &#123; return 0 &#125; var n: Int = 0 var resultCount: Int = nums.count for i in 0..&lt;nums.count-1 &#123; if nums[i] == nums[i+1] &#123; resultCount = resultCount - 1 n = n + 1 // i = 4 n = 3 &#125;else &#123; // i = 3 n = 3 // i = 5 n = 4 nums[i - n + 1] = nums[i+1] &#125; print(&quot;i=\(i) n=\(n)&quot;) &#125; // [1,1,1,1,2,2,11] // [1,2,11,1,1,1,2] // 4 -&gt; 1 // 6 -&gt; 2 // 出现多少次n 就用最后的i - n + 1 print(nums) return resultCount&#125; 然后，发现，其实用nums[i] != nums[k]来判断显得更为简洁和直观。而且还少了一个变量的空间。 123456789101112131415func removeDuplicates(_ nums: inout [Int]) -&gt; Int &#123; if nums.count == 0 &#123; return 0 &#125; var i: Int = 0 for k in 1..&lt;nums.count &#123; if nums[i] != nums[k] &#123; i = i + 1 nums[i] = nums[k] print(&quot;i=\(i) k=\(k) nums[i]=\(nums[i])&quot;) &#125; &#125; print(nums) return i+1&#125; 注：题中的使用 O(1) 额外空间的条件下完成，固定多少的变量下其实也是O(1)，并不是说只能用一个额外的变量。 四、小结耗时44毫秒，超过50.28%的提交记录，总提交数161。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《火影忍者》鸣人]]></title>
    <url>%2F2018%2F09%2F09%2F%E6%89%8B%E7%BB%98%2F%E3%80%8A%E7%81%AB%E5%BD%B1%E5%BF%8D%E8%80%85%E3%80%8B%E9%B8%A3%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[鸣人：我一向都是有话直说，这就是我的忍道。 我怎么感觉初稿比最后修改后的还好看些。。。]]></content>
      <categories>
        <category>涂鸦</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[好温暖的动漫]]></title>
    <url>%2F2018%2F09%2F08%2F%E6%89%8B%E7%BB%98%2F%E5%A5%BD%E6%B8%A9%E6%9A%96%E7%9A%84%E5%8A%A8%E6%BC%AB%2F</url>
    <content type="text"><![CDATA[《刺客伍六七》一部特别的暖心的动漫。没错，我要画的是里面的主角阿柒。 耗时较久的是脸的角度调整和手的画法。最终调整还是和原图有些出入，不过能将就看了。😄至于光影的处理，比较粗陋，完全看不出有光影的效果。看来我还是得从基本开始，平面图开始。。。 个人推荐：《刺客伍六七》片尾曲：《无论你多怪异我还是会喜欢你》，去qq音乐搜江蕙莲版 相信没看过的一定会有惊喜哦]]></content>
      <categories>
        <category>涂鸦</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我把我女神毁了。😭]]></title>
    <url>%2F2018%2F09%2F07%2F%E6%89%8B%E7%BB%98%2F%E6%88%91%E6%8A%8A%E6%88%91%E5%A5%B3%E7%A5%9E%E6%AF%81%E4%BA%86%2F</url>
    <content type="text"><![CDATA[这几天回去一坐着就想画画，这几天手痒啊。。。然后我决定画一画我的女神。嗯，提笔，开始。 额。。。你如果感觉不错的话，是因为没有看原图。。。 下面是原图，我以前用来做壁纸的。。。 结束了，一切都结束了，本来不想放上来，但是本着成长的想法，痛苦也要坚持，以后一定会画的更好的。 ps：本来想画何老师那篇泪水的，但是好难啊。画完好难看，就没继续了。]]></content>
      <categories>
        <category>涂鸦</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[将军与茶娘]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%B0%8F%E6%95%85%E4%BA%8B%E4%BB%AC%2F%E5%B0%86%E5%86%9B%E4%B8%8E%E8%8C%B6%E5%A8%98%2F</url>
    <content type="text"><![CDATA[有没有一句话、一段小故事能勾起你思绪万千，让你微笑却又叹息。 风霜满面的将军下马问路边茶娘：“大婶，你知道附近那个说话很温柔的卖茶姑娘住在哪吗”茶娘笑笑：“她呀，嫁了个好人家，衣食无忧，听说过的很好”将军叹息，从怀中掏出块手绢，请您帮我把这个还给她，谢谢她当年的茶点心。日落马远，茶娘小心将手绢系在手腕，叉腰向食客吆喝着：老娘今天开心，所有茶水半价。 普二丁说：“能在你心里一直是个小姑娘，这挺好的。”​ 由于人们不忍故事太过伤感，才有了许多后续。 1.古道边，难相望。茶娘摘下老态龙钟的人皮面具，容颜不改，望着天边的余晖，轻拂了下耳边的发髻， 转身走进茶馆。这时风悠悠的吹来，多少淡了点思念。你既已为驸马，又何必扯着我这故里旧人。誓言已凉，不必重温。天边黄草凄凄连天，一只老鹰也在这黄昏中飞的那么的遥远，似乎带走了所有的结局。残阳逐渐下落，古道尽头马蹄声传来，一道身影骑乘战马飞也似的奔来，茶娘略显慌乱， 仓促下竟来不及带上伪装，将军下马，眼中尽是温柔道：我已不再为将，公主金枝玉叶却不及二十年前的一缕茶香… 2.夕阳染红白马，茶娘望着将军远去的背影，伫立了良久。茶馆小二不解地问：“阿姐，你为何要骗他？”她淡淡地笑了笑，“世事如书，翻过去了就过去了。”正当茶娘眼含泪水时，身后传来粗犷的男声：“不知这里是否还缺个小二，后半生皆可伴你走下去的那种。”茶娘略带僵硬的转过身，将军张开双臂说：“我回来了。” 3.茶娘随后转身拭去那滴眼泪，笑着说道：“那傻瓜真信了呢，我心里早嫁给了他。”夕阳逐渐拉长了茶娘的影子…………傍晚收摊后，突然发现一个黑影靠着土墙，醉的一踏涂地，而嘴里仍然嘟囔着“二十年征战的伤痕不及你一句话”………… 也有伤感版本： 4.一缕残阳如血，将军骑马缓步而去，夕阳的余晖落在他疲惫的眼里。侍卫转回头悄声问：“将军，刚刚那位妇人不就是……”将军抬头闭了闭眼，“是。”“那为何……”将军提起缰绳策马飞奔，“世事如棋，一步错步步错。” 5.手下问将军，将军既然已经认出，又为何不相认呢？将军黯然，说道：我马上又将西征，这一去不知几个年头，生死难料，我已将她当年送我的定情物还于她。她安好，便好…… 6.急走百十步，随从问：将军为何不与其相认?将军：边关吃紧，此次能否归来都不知否，如何相认?食客：茶娘，为何慌骗这位将军?茶娘：将军没有了顾虑，才可打的胜战! 该段文字出处网易云热评：《性空山》 — 陈粒，评论者：帐号已注销原创：普二丁微博，2015年5月9日，标签：《小故事们》。原创：《将军与茶娘》简书，根据此热评展开的一段故事。 作者：张月半i配合轻音乐听，更有感觉哦。推荐《Somnambulating》 — 羽肿、《23：30》 – 曹思义 后记：有些版本整理自百度贴吧，有些是网易云音乐热评。推荐看普二丁的一些小故事，写的挺暖的挺有意思的。另外张月半i写的几个短篇也挺不错的。有没有更好的结局，请在评论区里留言哦。😄期待]]></content>
      <categories>
        <category>小故事们</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[故事的开端：海贼王]]></title>
    <url>%2F2018%2F09%2F06%2F%E6%89%8B%E7%BB%98%2F%E6%95%85%E4%BA%8B%E7%9A%84%E5%BC%80%E7%AB%AF%EF%BC%9A%E6%B5%B7%E8%B4%BC%E7%8E%8B%2F</url>
    <content type="text"><![CDATA[前言：我想我的故事就从这个不畏艰难的大男孩 – 路飞开始吧。毕竟，我也是要成为海贼王一样的男人。 给帽子加了一些纹理，大拇指那地方耗费了些时间。额头上的阴影忘记加了。 后记：好久没认真画画了，这么久来还是第一次，看到何老师的模版和详细的绘画步骤，真的发现画画需要的是一份耐心和专注。持之以恒，滴水穿石啊。喜欢手绘的同学一起加油哦。 参考文章：何老师海贼王教程]]></content>
      <categories>
        <category>涂鸦</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[18. 四数之和]]></title>
    <url>%2F2018%2F09%2F04%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F18.%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。 二、题目意思剖析：1234567给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 三、解题思路：从二元组。。。三元组。。。现在终于到了四元组。。。。其实不管是多少元组，都是一样的方法。到最后都转换到left和right两个指针来控制后两位数字。详细思路具体请参考：15. 三数之和、16. 最接近的三数之和 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** 思路：和三元组相似。我们需要找到 a+b+c+d = t */func fourSum(_ nums: [Int], _ target: Int) -&gt; [[Int]] &#123; // 二元组。。。三元组。。。终于到了四元组。。。。 if nums.count &lt; 4 &#123; return [] &#125; else if nums.count == 4 &#123; if nums[0] + nums[1] + nums[2] + nums[3] == target &#123; return [nums] &#125;else &#123; return [] &#125; &#125; else &#123; let tempNums: [Int] = nums.sorted&#123;$0&lt;$1&#125; let count = tempNums.count var fourSum: [[Int]] = Array.init() print(tempNums) for indexF in 0 ..&lt; count-3 &#123; // 剔除首位相同的元素 if (indexF != 0) &amp;&amp; (tempNums[indexF] == tempNums[indexF - 1])&#123; continue &#125; for indexH in indexF + 1 ..&lt; count-2 &#123; // 剔除第二位相同的元素，添加判断当 indexH 和 indexF不相邻时/ if (indexH != 0) &amp;&amp; (tempNums[indexH] == tempNums[indexH - 1]) &amp;&amp; indexH - 1 != indexF &#123; continue &#125; let tempArray = self.aFunction(numbers: tempNums, begin: indexH + 1, end: count) print(tempArray) var left:Int = 0 var right:Int = tempArray.count - 1 while left &lt; right &#123; // 临时的四个数字之和。 let tempTarget = tempNums[indexF] + tempNums[indexH] + tempArray[left] + tempArray[right] print(tempTarget) // 让tempTarget和目标值 target进行比对 if tempTarget == target &#123; let tempFourSum = [tempNums[indexF],tempNums[indexH],tempArray[left],tempArray[right]] fourSum .append(tempFourSum) // 如果两个数字相同，我们直接跳到下一个循环。 while left &lt; right &amp;&amp; tempArray[left] == tempArray[left+1] &#123; left = left + 1 &#125; // 如果两个数字相同，我们直接跳到下一个循环。 while left &lt; right &amp;&amp; tempArray[right] == tempArray[right-1] &#123; right = right - 1 &#125; left = left + 1 right = right - 1 &#125; if tempTarget &lt; target &amp;&amp; left &lt; right&#123; left = left + 1 &#125;else if tempTarget &gt; target &amp;&amp; left &lt; right&#123; right = right - 1 &#125; &#125; &#125; &#125; return fourSum &#125;&#125;func aFunction(numbers: Array&lt;Int&gt;, begin: Int, end: Int) -&gt; Array&lt;Int&gt; &#123; let newNumbers = Array(numbers[begin..&lt;end]) return newNumbers&#125; 四、小结耗时220毫秒，超过71.43%的提交记录，总提交数282。 本题和15. 三数之和、16. 最接近的三数之和都可归为一类处理，如果有困惑的地方可以前后看看这几篇文章哦，解题思路差不多。 小哥哥小姐姐们有其他好的方法请留言哦，有困惑的地方也非常乐意一起探讨呢。😄!]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[16. 最接近的三数之和]]></title>
    <url>%2F2018%2F08%2F08%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F16.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 二、题目意思剖析：最接近其实可以转化为，(三数之和 - target)的绝对值最小。result = |三数之和 - target|，只需要找出最小的result即可。result理论上最小值为0，即和target相等 三、解题思路：最简单的是三层遍历。这里就不说了，复杂度太高。不过也通过了leetcode检测。耗时400ms，超过百分之11的提交记录。 其实我们可以将其简化为 和 上一题15. 三数之和一样的模式上。也就是将最前面的数字抽出来，然后让left指针和right指针在该数字之后的数组里进行滑动。找出三数之和 - target的绝对值的最小值即可。判断会有点多。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657func threeSumClosest(_ nums: [Int], _ target: Int) -&gt; Int &#123; if(nums.count &lt; 3)&#123; var result = 0 for value in nums &#123; result = result + value &#125; return result; &#125; var tempNums = nums.sorted&#123;$0&lt;$1&#125; let count = tempNums.count var threeSum = tempNums[0] + tempNums[1] + tempNums[2] print(tempNums) for indexF in 0 ..&lt; count &#123; if (indexF != 0) &amp;&amp; (tempNums[indexF] == tempNums[indexF - 1])&#123; continue &#125; let tempArray = self.aFunction(numbers: tempNums, begin: indexF + 1, end: count) print(tempArray) var left:Int = 0 var right:Int = tempArray.count - 1 while left &lt; right &#123; print(threeSum) let newOffsetValue = tempArray[left] + tempArray[right] + tempNums[indexF] - target if(newOffsetValue == 0)&#123; return target; &#125; let result = threeSum - target if(result &lt; 0)&#123; if(newOffsetValue &lt; 0)&#123; if(newOffsetValue &gt; result)&#123; threeSum = newOffsetValue + target &#125; left = left + 1 &#125;else&#123; if(newOffsetValue &lt; abs(result))&#123; threeSum = newOffsetValue + target &#125; right = right - 1 &#125; &#125;else&#123; if(newOffsetValue &lt; 0)&#123; if(abs(newOffsetValue) &lt; result)&#123; threeSum = newOffsetValue + target &#125; left = left + 1 &#125;else&#123; if(newOffsetValue &lt; result)&#123; threeSum = newOffsetValue + target &#125; right = right - 1 &#125; &#125; &#125; &#125; return threeSum&#125; 四、小结耗时40毫秒，超过77.78%的提交记录，总提交数125。 有其他好的方法请极速留言，非常乐意一起探讨。😄!]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[20. 有效的括号]]></title>
    <url>%2F2018%2F08%2F08%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 二、题目意思剖析：1234567891011121314输入: &quot;()&quot;输出: true输入: &quot;()[]&#123;&#125;&quot;输出: true输入: &quot;(]&quot;输出: false输入: &quot;([)]&quot;输出: false输入: &quot;&#123;[]&#125;()&#123;&#125;&quot;输出: true 三、解题思路：核心思想 : 对称，将字符串分为左右两个部分，然后检测对称。左边用strings数组保存，保存左括号。右边沿用当前的字符串 是右括号，然后进行对称匹配。一旦检测到不对称，就返回false。一旦检测到对称，就将他们两个消除。进行下一次比对。strings保存方式为栈式保存。 1234567891011121314151617181920212223func isValid(_ s: String) -&gt; Bool &#123; var strings: [Character] = [] for char in s &#123; if char == &quot;&#123;&quot; || char == &quot;(&quot; || char == &quot;[&quot; &#123; strings .append(char) &#125;else &#123; if (strings.isEmpty) &#123; return false &#125; if char == &quot;&#125;&quot; &amp;&amp; strings.last != &quot;&#123;&quot; &#123; return false &#125; if char == &quot;)&quot; &amp;&amp; strings.last != &quot;(&quot; &#123; return false &#125; if char == &quot;]&quot; &amp;&amp; strings.last != &quot;[&quot; &#123; return false &#125; strings .removeLast() &#125; &#125; return strings.isEmpty&#125; 四、小结耗时24毫秒，超过65.71%的提交记录，总提交数76。 有其他好的方法请极速留言，非常乐意一起探讨。😄!]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[14. 最长公共前缀]]></title>
    <url>%2F2018%2F08%2F07%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[一、题目原型： 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 二、题目意思剖析：123456789输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。说明:所有输入只包含小写字母 a-z 。 三、解题思路：题目意思比较简单，首先我们需要找到最短的那个字符串，因为要找的公共串那个最短的字符串一定是包含的，我们需要的是最短字符串的长度minString。我们需要一个变量maxLenth，表示最大长度。我们先取到数组中第一个元素的prefix，然后和之后的元素的prefix进行比对。例子：[“flower”,”flow”,”flight”]第一轮：maxLenth = 0，prefix = f，第0个元素prefix和后面的都相同，maxLenth + 1第二轮：maxLenth = 1，prefix = fl，第0个元素prefix和后面的都相同，maxLenth + 1第三轮：maxLenth = 2，prefix = flo，第0个元素prefix和第2个元素不同(fli)，直接break 12345678910111213141516171819202122232425262728293031323334func longestCommonPrefix(_ strs: [String]) -&gt; String &#123; var minString: String = &quot;&quot; if strs.count &gt; 0 &#123; minString = strs.min()! &#125; var maxLenth: Int = 0 var prefix: String = &quot;&quot; var tempIndex: Int = 0 for _ in 0..&lt;minString.count &#123; prefix = String(strs[0].prefix(maxLenth+1)) for j in 1..&lt;strs.count&#123; if prefix == String(strs[j].prefix(maxLenth+1)) &#123; tempIndex = tempIndex + 1 if tempIndex == strs.count - 1 &#123; maxLenth = maxLenth + 1 tempIndex = 0 &#125; &#125; else &#123; tempIndex = 0 break &#125; &#125; &#125; if strs.count == 1 &#123; return strs[0] &#125;else &#123; if maxLenth == 0 &#123; return &quot;&quot; &#125;else &#123; return String(strs[0].prefix(maxLenth)) &#125; &#125;&#125; // 简化代码方案思路：取到数组里的第0个元素，然后把它扔进取strs里遍历，从1开始。如果发现strs的其他元素不包含第0个元素，就让第0个元素长度-1。12345678910111213141516func longestCommonPrefix(_ strs: [String]) -&gt; String &#123; guard var prefix = strs.first else &#123; return &quot;&quot; &#125; for i in 1..&lt;strs.count &#123; // 如果strs里不包括第0个元素，就让他的长度-1 while(!strs[i].hasPrefix(prefix)) &#123; // 关键两句代码 prefix = String(prefix.prefix(prefix.count-1)) if (prefix.count == 0) &#123; return &quot;&quot; &#125; &#125; &#125; return prefix&#125; 四、小结耗时20毫秒，超过96.51%的提交记录，总提交数118。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[15. 三数之和]]></title>
    <url>%2F2018%2F08%2F07%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。 二、题目意思剖析：1234例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[[-1, 0, 1], [-1, -1, 2]] 三、解题思路：3.1.首先想到的最简单最傻的做法是三层循环，时间复杂度为O(n的三次方)。。。想想都觉得耗时。。。非常不建议，只是一个思路而已。 123456789101112131415161718192021222324252627func threeSum(_ nums: [Int]) -&gt; [[Int]] &#123; var newNums: [Int] = [] var haha:[[Int]] = [] for i in 0..&lt;nums.count &#123; for j in i+1..&lt;nums.count &#123; for k in j+1..&lt;nums.count &#123; if nums[i] + nums[j] + nums[k] == 0 &#123; newNums.append(nums[i]) newNums.append(nums[j]) newNums.append(nums[k]) newNums.sort() if haha.contains(newNums) &#123; newNums.removeAll() continue &#125; haha.append(newNums) &#125; newNums.removeAll() &#125; &#125; &#125; return haha&#125; 3.2.经过耗时太长的惨痛经历，痛定思痛，我觉得从题目“三数之和=0”入手。排除三个数都为0的情况，也就是[0,0,0]；请他情况必定是有一个负数的。所以我们可以首先就排个序。123//第一步：排序比如刚开始是[-1, 0, 1, 2, -1, -4]排序后变成是[-4, -1, -1, 0, 1, 2] 排序完，是不是觉得思路有了，对的。我们只需要遍历前面的负数和0，也就是&gt;0的我们统统不要了。我们需要拿到第一个负数。123456for i in 0..&lt;MutNums.count &#123; if (MutNums[i] &gt; 0) &#123; break; &#125; // MutNums[i]就是一个负数&#125; 拿到第一个负数后，我们只需要再拿到后面两个数，与之相加=0即可。后面两个数我们用两个指针来表示，j和k，一个是从左边往右边走，一个是从最右边往前走。有些思想就是想通的，之前的两数之和就是这种思路。先排好序，左边一个left指针，右边一个right指针，如果left+right &gt; result，那么right往左移，如果left+right &lt; result，那么说明相加得数不够，就需要left往右移。找到相加之和相等的就行。此题，也是如此。12345let target = 0 - MutNums[i]; // 这个就是动态的reslutvar j = i+1, k = MutNums.count - 1if (MutNums[j] + MutNums[k] == target) &#123; //这就回到了两数之和那个简单的问题。&#125; 不过在这里要注意一个问题，就是题目中提到的“答案中不可以包含重复的三元组”，所以我们需要把相同的数字过滤掉。其实很简单，只需要往下或者往前走一位，其他什么都不要做。123while j &lt; k &amp;&amp; MutNums[j] == MutNums[j+1] &#123; j = j + 1&#125; 贴出代码123456789101112131415161718192021222324252627282930313233343536373839404142434445func threeSum(_ nums: [Int]) -&gt; [[Int]] &#123; var MutNums: [Int] = nums var newNums: [Int] = [] var haha:[[Int]] = [] // 1.排序 对于MutNums[i]来说，我们只需要负数和0，因为三个数之和为0，一定是有一个数为负数的，当然除去三个数都为0的情况。所以，我们取非正数。 MutNums.sort() for i in 0..&lt;MutNums.count &#123; if (MutNums[i] &gt; 0) &#123; break; &#125; // 如果两个数字相同，我们直接跳到下一个循环。 if (i &gt; 0 &amp;&amp; MutNums[i] == MutNums[i-1]) &#123; continue &#125; let target = 0 - MutNums[i]; var j = i+1, k = MutNums.count - 1 while j &lt; k &#123; // 2.找到后面的两个与MutNums[i]对应的数字 if (MutNums[j] + MutNums[k] == target) &#123; newNums.append(MutNums[i]) newNums.append(MutNums[j]) newNums.append(MutNums[k]) haha.append(newNums) newNums.removeAll() // 如果两个数字相同，我们直接跳到下一个循环。 while j &lt; k &amp;&amp; MutNums[j] == MutNums[j+1] &#123; j = j + 1 &#125; // 如果两个数字相同，我们直接跳到下一个循环。 while j &lt; k &amp;&amp; MutNums[k] == MutNums[k-1] &#123; k = k - 1 &#125; // 否则就往中间靠拢 j = j + 1;k = k - 1 &#125;else if (MutNums[j] + MutNums[k] &lt; target) &#123; // 如果后面两数相加小于target，说明左边还得往右移 j = j + 1 &#125;else &#123; // 如果后面两数相加大于target，说明右边就要往左移 k = k - 1 &#125; &#125; &#125; return haha&#125; 12运行数组[13,9,1,12,-7,-12,7,3,9,6,-7,4,9,5,5,-7,4,11,1,-2,12,3,-12,-15,0,-12,-6,-1,7,-5,-4,-3,12,4,-14,-10,-1,8,1,-6,-1,9,13,-14,-1,-5,-6,-12,-8,2,2,11,13,-3,11,-2,1,-10,4,-15,-8,7,-11,11,-4,-10,-13,3,5,3,12,11,-11,2,12,3,13,13,-2,12,-7,-15,8,-9,-10,-4,-4,6,1,-15,-2,0,-1,2,-3,10,-1,-9,-10,-11,1,-13,-15,5,-3,5,-7,-5,-5,6,14,3,-1,7,1,-4,-12,12,-13,-4,4,0,3,-12,9,-15,6] 耗时对比：1.三层循环 347.76ms2.滑尺优化方案 2.64ms话不多说，感受下这个天壤之别。 四、小结耗时164毫秒，超过100%的提交记录，总提交数313。 有任何疑问都可以留言，非常乐意一起探讨。😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[12. 整数转罗马数字]]></title>
    <url>%2F2018%2F07%2F19%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F12.%20%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[一、题目原型：可参考 13. 罗马数字转整数 二、题目意思剖析：其实就是和 13. 罗马数字转整数反着来12345678910111213141516输入: 3输出: &quot;III&quot;输入: 4输出: &quot;IV&quot;输入: 9输出: &quot;IX&quot;输入: 58输出: &quot;LVIII&quot;解释: C = 100, L = 50, XXX = 30, III = 3.输入: 1994输出: &quot;MCMXCIV&quot;解释: M = 1000, CM = 900, XC = 90, IV = 4. 三、解题思路：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677func intToRoman(_ num: Int) -&gt; String &#123; if num&lt;1 || num&gt;3999 &#123; return &quot;&quot; &#125; var tempNum = num var arr: [Int] = [] while tempNum != 0 &#123; arr.append(tempNum % 10) tempNum = tempNum / 10 &#125; var numArr: [Int] = Array.init(repeating: 0, count: arr.count) for i in 0..&lt;arr.count &#123; let haha: Int = Int.init(pow(10.0, Double(i))) numArr[arr.count - 1 - i] = haha * arr[i] &#125; var resultStr: String = &quot;&quot; for i in 0..&lt;numArr.count &#123; var num: Int = numArr[i] if num == 900 &#123; resultStr += &quot;CM&quot; &#125;else if num == 400 &#123; resultStr += &quot;CD&quot; &#125;else if num == 90 &#123; resultStr += &quot;XC&quot; &#125;else if num == 40 &#123; resultStr += &quot;XL&quot; &#125;else if num == 9 &#123; resultStr += &quot;IX&quot; &#125;else if num == 4 &#123; resultStr += &quot;IV&quot; &#125;else if num % 1000 == 0 &#123; for _ in 0..&lt;num / 1000 &#123; resultStr += &quot;M&quot; &#125; &#125;else if num &gt; 500 &amp;&amp; num &lt; 1000&#123; num = num - 500 resultStr += &quot;D&quot; for _ in 0..&lt;num / 100 &#123; resultStr += &quot;C&quot; &#125; &#125;else if num == 500 &#123; resultStr += &quot;D&quot; &#125;else if num % 100 == 0 &amp;&amp; num &lt; 500&#123; for _ in 0..&lt;num / 100 &#123; resultStr += &quot;C&quot; &#125; &#125;else if num &gt; 50 &amp;&amp; num &lt; 100&#123; num = num - 50 resultStr += &quot;L&quot; for _ in 0..&lt;num / 10 &#123; resultStr += &quot;X&quot; &#125; &#125;else if num == 50 &#123; resultStr += &quot;L&quot; &#125;else if num % 10 == 0 &amp;&amp; num &lt; 50 &#123; for _ in 0..&lt;num / 10 &#123; resultStr += &quot;X&quot; &#125; &#125;else if num &lt; 10 &amp;&amp; num &gt; 5 &#123; num = num - 5 resultStr += &quot;V&quot; for _ in 0..&lt;num &#123; resultStr += &quot;I&quot; &#125; &#125;else if num == 5 &#123; resultStr += &quot;V&quot; &#125;else if num &lt;= 3 &#123; for _ in 0..&lt;num / 1 &#123; resultStr += &quot;I&quot; &#125; &#125; &#125; return resultStr&#125; 12345678910111213141516171819202122232425// 优化方案func intToRoman(_ num: Int) -&gt; String &#123; if num&lt;1 || num&gt;3999 &#123; return &quot;&quot; &#125; var lala = num var resultStr: String = &quot;&quot; let numList = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] let romanList = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;,&quot;V&quot;, &quot;IV&quot;, &quot;I&quot;] for i in 0..&lt;numList.count &#123; if lala &lt; numList[i] &#123; continue &#125; while lala &gt;= numList[i] &#123; lala = lala - numList[i] resultStr += romanList[i] &#125; &#125; return resultStr&#125; 四、小结第一种方法看起来是不是特麻烦，我写起来的时候也是，得想清楚。。。之后优化的方案清晰多了。 耗时96毫秒，超过28.57%的提交记录，总提交数3999。 有其他好的方法请极速留言，非常乐意一起探讨。😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[13. 罗马数字转整数]]></title>
    <url>%2F2018%2F07%2F19%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F13.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、题目原型： 罗马数字包含以下七种字符：I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 六种特殊字符：IV， IX， XL， XC，CD 和 CM。1234567特殊字符 数值IV 4IX 9XL 40XC 90CD 400CM 900 二、题目意思剖析：将罗马数字从后往前依次筛选1.先筛选出特殊字符，+对应的数值，然后进行剔除2.在筛选普通字符，+对应的数值，然后进行剔除最后得出result。 12345678910111213141516输入: &quot;III&quot;输出: 3输入: &quot;IV&quot;输出: 4输入: &quot;IX&quot;输出: 9输入: &quot;LVIII&quot;输出: 58解释: C = 100, L = 50, XXX = 30, III = 3.输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 三、解题思路：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 看起来清晰，然而写起来麻烦。func romanToInt(_ s: String) -&gt; Int &#123; var sum: Int = 0 var str: String = s var special: [String] = [&quot;IV&quot;,&quot;IX&quot;,&quot;XL&quot;,&quot;XC&quot;,&quot;CD&quot;,&quot;CM&quot;] for i in 0..&lt;special.count &#123; if str.contains(special[i]) &#123; let range: Range&lt;String.Index&gt; = str.range(of: special[i])! str.removeSubrange(range) if special[i] == &quot;CM&quot; &#123; sum = sum + 900 &#125;else if special[i] == &quot;CD&quot; &#123; sum = sum + 400 &#125;else if special[i] == &quot;XC&quot; &#123; sum = sum + 90 &#125;else if special[i] == &quot;XL&quot; &#123; sum = sum + 40 &#125;else if special[i] == &quot;IX&quot; &#123; sum = sum + 9 &#125;else if special[i] == &quot;IV&quot; &#123; sum = sum + 4 &#125; print(str) print(sum) &#125; &#125; for char in str &#123; let temp = String.init(char) if temp == &quot;M&quot; &#123; sum = sum + 1000 &#125;else if temp == &quot;D&quot; &#123; sum = sum + 500 &#125;else if temp == &quot;C&quot; &#123; sum = sum + 100 &#125;else if temp == &quot;L&quot; &#123; sum = sum + 50 &#125;else if temp == &quot;X&quot; &#123; sum = sum + 10 &#125;else if temp == &quot;V&quot; &#123; sum = sum + 5 &#125;else if temp == &quot;I&quot; &#123; sum = sum + 1 &#125; &#125; return sum&#125; 1234567891011121314151617181920212223// 优化写法func romanToInt(_ s: String) -&gt; Int &#123;var sum: Int = 0var str: String = slet specialRoman: [String] = [&quot;IV&quot;,&quot;IX&quot;,&quot;XL&quot;,&quot;XC&quot;,&quot;CD&quot;,&quot;CM&quot;]let specialNum: [Int] = [4, 9, 40, 90, 400, 900]let normalRoman: [String] = [&quot;M&quot;, &quot;D&quot;, &quot;C&quot;, &quot;L&quot;, &quot;X&quot;, &quot;V&quot;, &quot;I&quot;]let normalNum: [Int] = [1000, 500, 100, 50, 10, 5, 1]for i in 0..&lt;specialRoman.count &#123; while str.contains(specialRoman[i]) &#123; let range: Range&lt;String.Index&gt; = str.range(of: specialRoman[i])! str.removeSubrange(range) sum = sum + specialNum[i] &#125;&#125;for i in 0..&lt;normalNum.count &#123; while str.contains(normalRoman[i]) &#123; let range: Range&lt;String.Index&gt; = str.range(of: normalRoman[i])! str.removeSubrange(range) sum = sum + normalNum[i] &#125;&#125;return sum 四、小结耗时216毫秒，超过20.53%的提交记录，总提交数3999。 有其他好的方法请极速留言，非常乐意一起探讨。😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[9. 回文数]]></title>
    <url>%2F2018%2F07%2F17%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F9.%20%E5%9B%9E%E6%96%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、题目原型： 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 二、题目意思剖析：回文数可以看作一个对称的字符串。12345678910输入: 121输出: true输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 三、解题思路：第一种思路：用数组将每个数字存起来，看是否对称1.如果该整数为负数，就不是回文数。比如-123，反过来是321-，不管如何反都不是。2.遍历将余数保存在一个数组里，然后遍历该数组，如果左右对称 –12 func isPalindrome(_ x: Int) -&gt; Bool { if x &lt; 0 { return false } var remainder: Int = 0 var tempX: Int = x var array: Array = Array.init(repeating: 0, count: 0) while tempX != 0 { remainder = tempX % 10 tempX = tempX / 10 array .append(remainder) } for i in 0..&lt;array.count { if array[i] != array[array.count - 1 - i] { return false } } return true }123#### 第二种思路：将数字反序，然后对比和原整数是否相等（推荐，耗时较少，少了一步遍历的时间） func isPalindrome(_ x: Int) -&gt; Bool { if x &lt; 0 { return false } var tempX: Int = x var result: Int = 0 while tempX != 0 { result = result * 10 + tempX % 10 tempX = tempX / 10 } if result != x { return false } return true }` 四、小结如果是第一种方法大概是300ms，第二种大概是200ms。 耗时212毫秒，超过40.87%的提交记录，总提交数11508。 有其他好的方法请极速留言，非常乐意一起探讨。😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[11.盛最多水的容器]]></title>
    <url>%2F2018%2F07%2F17%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 二、题目意思剖析：实质：找最大面积 三、解题思路：12345678910111213141516171819202122func maxArea(_ height: [Int]) -&gt; Int &#123; guard height.count &gt; 0 else &#123; return 0 &#125; var l: Int = 0 var r: Int = height.count - 1 var maxArea = Int.min while l &lt; r &#123; // 找出两个高度之间更小的那个，找出最大面积 maxArea = max(maxArea, (r - l) * min(height[l], height[r])) // 如果左边高度 &lt; 右边高度，左边+1 if height[l] &lt; height[r] &#123; l = l + 1 &#125;else &#123; // 反之，右边-1 r = r - 1 &#125; &#125; return maxArea&#125; 四、小结因为如果高度不够，水就会溢出，所以就需要找更矮的那个高度。然后乘以他们之间的x距离，就是面积。通过两个指针l和r，节省了一半的时间。 耗时44毫秒，超过22.22%的提交记录，总提交数49。]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[7. 反转整数]]></title>
    <url>%2F2018%2F07%2F16%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F7.%20%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个 32 位有符号整数，将整数中的数字进行反转。输入: 123输出: 321输入: -123输出: -321输入: 120输出: 21 二、题目意思剖析：123用原整数一直余10，保存起来和sum*10相加再赋值给sumsum = sum * 10 + tempX % 10tempX = tempX / 10 三、解题思路：123456789101112func reverse(_ x: Int) -&gt; Int &#123; var tempX:Int = x var sum: Int = 0 while tempX != 0 &#123; sum = sum * 10 + tempX % 10 tempX = tempX / 10 &#125; if sum &gt; Int32.max || sum &lt; Int32.min &#123; return 0 &#125; return sum&#125; 四、小结就比较简单，普通的算法。 耗时32毫秒，超过62.5%的提交记录，总提交数1032。 有其他好的方法请极速留言，非常乐意一起探讨。😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[6. Z字形变换]]></title>
    <url>%2F2018%2F07%2F16%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F6.%20Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[一、题目原型： 将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数： 输入: s = “PAYPALISHIRING”, numRows = 3 输出: “PAHNAPLSIIGYIR” 输入: s = “PAYPALISHIRING”, numRows = 4 输出: “PINALSIGYAHRPI”实现一个将字符串进行指定行数变换的函数:string convert(string s, int numRows); 二、题目意思剖析：12345678910numRows = 3P A H NA P L S I I GY I RnumRows = 4P I NA L S I GY A H RP I 三、解题思路：3.1. 将原字符串按照“z字转换规律”保存进一个二维数组3.2.将该二维数组横竖对调，得到最后的二维数组3.3.用字符串拼接得到最后的答案核心思路：找规律，找关键的几个数据和numRows、字符串总长度之间的关系。下图中方框内表示一个单元格。 第一步：能够看出，这个排列是由一个个单元格(相同的排列)组成。123456789 P I N A L S I G Y A H R P I其中，单元格是 P A L Y A P 第二步：算出每一个单元所包含的字符个数很简单可以看出，每个单元是由最长的那一列+中间的那几个字符。而中间那些字符，刚好是除去最上面和最下面的那些。所以： 1let letterCount = numRows + (numRows - 2) 第三步：每个单元格包含的列数1表示是行数最大那一列，(numRows - 2)是中间过渡的那几列1let cols: Int = 1 + (numRows - 2) 第四步：总共有多少个单元格1234567var count: Int = 0while letterCount*count &lt;= letters.count &#123; count = count + 1&#125;// 因为最后count会再次累加1，所以需要减1.count = count - 1 第五步：总共列数12345678910111213// 最终列数var allCols: Int = 0// 余数：比如字符长度为17，17 % 6 = 5let remainder = letters.count % letterCountif remainder == 0 &#123; // 说明刚好有整数个单元格 allCols = count * cols&#125;else if remainder &gt;= numRows &amp;&amp; remainder &lt; letterCount &#123; //如果余数大于或者行数，并且小于一个单元格所包含的最大字符数，allCols = 前面整数个的单元格列数 + 1 + (余数 - numRows) allCols = count * cols + 1 + (remainder - numRows)&#125;else &#123; // 比如上面的例子， PAYPALISHIRING中，结果余数 = 14%6 = 2，2 &lt; numRows，所以allCols = 前面整数个的单元格列数 + 1 allCols = count * cols + 1&#125; 12345678910111213141516171819202122// 1.前二维数组var allConvert = dim(allCols, dim(numRows, &quot;*&quot;))var index: Int = 0 // 总字符串索引for i in 0..&lt;allCols &#123; // i % cols，余数 - 指的是字母离底部多长。 if i % cols == 0 &#123; // 当余数为0时，就是最长列的时候。 var convert: [String] = Array.init(repeating: &quot;*&quot;, count: numRows) var j: Int = 0 while index &lt; letterCount * (i/cols + 1) &amp;&amp; index &lt; letters.count &amp;&amp; j &lt; numRows &#123; convert[j] = letters[index] allConvert[i] = convert index = index + 1 j = j + 1 &#125; &#125;else &#123; // 其他时候，就是用（ 最大行数 - 1 - 余数 ） var convert: [String] = Array.init(repeating: &quot;*&quot;, count: numRows) convert[numRows - 1 - i%cols] = letters[index] allConvert[i] = convert index = index + 1 &#125;&#125;print(allConvert) 这里需要一个创建二维数组的函数1234// 创建二维数组func dim&lt;T&gt;(_ count: Int, _ value: T) -&gt; [T] &#123; return [T](repeating: value, count: count)&#125; 第六步：横竖置换1234567891011[[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], [&quot;*&quot;, &quot;*&quot;, &quot;e&quot;, &quot;*&quot;], [&quot;*&quot;, &quot;f&quot;, &quot;*&quot;, &quot;*&quot;], [&quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;], [&quot;*&quot;, &quot;*&quot;, &quot;k&quot;, &quot;*&quot;], [&quot;*&quot;, &quot;l&quot;, &quot;*&quot;, &quot;*&quot;]] 变成 [[&quot;a&quot;, &quot;*&quot;, &quot;*&quot;, &quot;g&quot;, &quot;*&quot;, &quot;*&quot;], [&quot;b&quot;, &quot;*&quot;, &quot;f&quot;, &quot;h&quot;, &quot;*&quot;, &quot;l&quot;], [&quot;c&quot;, &quot;e&quot;, &quot;*&quot;, &quot;i&quot;, &quot;k&quot;, &quot;*&quot;], [&quot;d&quot;, &quot;*&quot;, &quot;*&quot;, &quot;j&quot;, &quot;*&quot;, &quot;*&quot;]] 12345678// 将数组横转，横 -&gt; 竖// i[0,6) j[0,4) -&gt; i[0,4) j[0,6)var resultConverts = dim(numRows, dim(allCols, &quot;*&quot;))for i in 0..&lt;allCols &#123; for j in 0..&lt;numRows &#123; resultConverts[j][i] = allConvert[i][j] &#125;&#125; 第七步：拼接最终字符串12345678910var result: String = &quot;&quot;for i in 0..&lt;numRows &#123; for j in 0..&lt;allCols &#123; if resultConverts[i][j] != &quot;*&quot; &#123; result.append(resultConverts[i][j]) &#125; &#125;&#125;print(resultConverts)// result就是我们需要的答案 四、小结耗时1768毫秒，超过3.85%的提交记录，总提交数1158。 思路完全正确的，就是耗时太长了， 有其他好的方法请极速留言，非常乐意一起探讨。😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[8. 字符串转整数 (atoi)]]></title>
    <url>%2F2018%2F07%2F16%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F8.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%20(atoi)%2F</url>
    <content type="text"><![CDATA[一、题目原型： 实现 atoi，将字符串转为整数。在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。若函数不能执行有效的转换，返回 0。说明：假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。如果数值超过可表示的范围，则返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 二、题目意思剖析：123456789101112131415161718192021输入: &quot;42&quot;输出: 42输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 1.第一个非空字符前如果有空格，去掉。2.第一个非空字符只有三种选项：+ - 数字，否则返回03.接下来将连续的数字连接起来，中间不可以有除数字外的其他字符 三、解题思路：1.创建相应需要的变量1234567let arr: [String] = [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;]var result: Int = 0 // 最终结果var numbers: [String] = []for char in str &#123; let temp: String = String.init(char) numbers.append(temp)&#125; 2.几个重要的标记123var flag: Int = 1 // 表示最终结果(整数)的符号，默认为1var space: Int = -1 // 表示当前字符是否为空格，如果不等于-1，就不是空格了。var valid: Bool = false //表示是否出现了第一个有效的字符(+ - 或者数字) 3.遍历numbers，获取最终结果1234567891011121314151617181920212223242526272829for i in 0..&lt;numbers.count &#123; // 1.排除空格 if (numbers[i] == &quot; &quot;) &amp;&amp; space == -1 &#123; continue &#125;else &#123; space = i &#125; // 2.第一个非空字符字符为 数字或正、负号，将valid标记好 if (numbers[i] == &quot;-&quot; || numbers[i] == &quot;+&quot;) &amp;&amp; !valid&#123; flag = (numbers[i] == &quot;+&quot;) ? 1 : -1 valid = true continue &#125;else if (arr .contains(numbers[i])) &#123; valid = true // 3.将numbers中的元素转换为int类型，将result*10叠加起来。 result = result*10 + Int(numbers[i])! if result &gt; Int32.max &amp;&amp; flag == 1&#123; result = Int(Int32.max) return result &#125;else if result*flag &lt;= Int32.min &amp;&amp; flag == -1&#123; result = Int(Int32.min) return result &#125; &#125;else &#123; break &#125;&#125;return result * flag 4.举例 ：“ –0000123”1234561.前面的空格会跳过，直到第一个“-”。此时space = i，i = 3，进入下一步2.此时是“-”，找到了第一个有效的非空字符，valid = true，然后continue3.接下来是第二个“-”，但是!valid = false，不会进入if (numbers[i] == &quot;-&quot; || numbers[i] == &quot;+&quot;) &amp;&amp; !valid&#123;&#125;这个判断，会直接到else，会直接break，此时，result = 0 四、小结耗时76毫秒，超过11.9%的提交记录，总提交数1079。 有其他好的方法请极速留言，非常乐意一起探讨。😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[5. 最长回文子串]]></title>
    <url>%2F2018%2F07%2F13%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 二、题目意思剖析：回文其实是对称的一个字符串。比如：aba 、xyx、 mnnm、xoox 这样子。。。123456输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot;也是一个有效答案。输入: &quot;cbbd&quot;输出: &quot;bb&quot; 三、解题思路：中心法 官方解释：事实上，只需使用恒定的空间，我们就可以在 O(n^2) 的时间内解决这个问题。我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n−1 个这样的中心。你可能会问，为什么会是 2n−1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如 “abba” 的中心在两个 ‘b’ 之间）。 我的理解：我们根据对称的这个特性，来进行查找，以一个点为中心，两个指针左右移动，如果两边对应的字母相同，那么就继续移动，直到超出边界或者两边字母不同。 安排： 1234567891011121314// 返回当前回文最大的长度func haha(_ letters: [String],_ left: Int, _ right: Int) -&gt; (Int) &#123; var L:Int = left var R: Int = right // 当左边指针不小于0，当右边指针不超过字符串长度 // 并且左右两个数值要相等 while L&gt;=0 &amp;&amp; R&lt;letters.count &amp;&amp; letters[L] == letters[R] &#123; L = L - 1 R = R + 1 &#125; return R - L - 1&#125; 12345678910111213141516171819202122232425262728293031func longestPalindrome(_ s: String) -&gt; String &#123; var letters: [String] = [] for char in s &#123; let str: String = String.init(char) letters.append(str) &#125; var start:Int = 0 var end: Int = 0 var huiwen: String = &quot;&quot; for i in 0..&lt;letters.count &#123; // 这分为两种情况：1.回文长度为奇数时，中心在中间那个字母 // 2.回文长度为偶数时，中心在两个字母之间 let len1: Int = haha(letters, i, i) let len2: Int = haha(letters, i, i+1) // 取最大值 let len: Int = len1 &gt; len2 ? len1 : len2 if len &gt; end - start &#123; start = i - (len - 1) / 2 end = i + len / 2 &#125; &#125; for i in start..&lt;end+1 &#123; huiwen.append(letters[i]) &#125; return huiwen&#125; 四、小结一切一切的算法，前提是要找到规律。然后一步一步剖析找出最好的算法。在本题中，我的笔记思路只画出了一种情况，还有另一种情况就是回文长度为偶数时，中心在两个字母之间，也是一样的规律去找。最后比较这两种情况，找出最大值就行了。 耗时94毫秒，超过55.56%的提交记录，总提交数1056。 有其他好的方法请极速留言，非常乐意一起探讨。😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[3.无重复字符的最长子串]]></title>
    <url>%2F2018%2F07%2F10%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个字符串，找出不含有重复字符的最长子串的长度。 二、题目意思剖析：12345给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列 而不是子串。 三、解题思路：3.1暴力破解 12345678910// 分析// abcabcdb// abcd -- 答案a b c a bab bc ca ab bcabc 3 bca 3 cab 3 abc bcd 3abca ❌ bcab ❌ cabc ❌ abcd 4 bcdb ❌ abcdb ❌// 1.找出每次遍历时当前string的最长substring，当然不能出现重复的字母// 2.从中拿到最长的 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 上代码// 注：resultLength是个全局变量func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123; if s.count &lt;= 1 &#123; print(s) return s.count &#125; var letters: [Character] = [] for char in s &#123; letters .append(char) &#125; print(letters) var subString: String = &quot;&quot; var maxLength: Int = 1 for i in 0..&lt;letters.count - 1 &#123; subString .append(letters[i]) for j in i+1..&lt;letters.count &#123; if !subString .contains(letters[j]) &#123; subString .append(letters[j]) maxLength = maxLength + 1 // 用全局变量resultLength保存最大的长度 resultLength = maxLength &gt; resultLength ? maxLength : resultLength &#125;else &#123; print(subString) print(maxLength) // 用全局变量resultLength保存最大的长度 resultLength = maxLength &gt; resultLength ? maxLength : resultLength subString .removeAll() maxLength = 1 break &#125; &#125; // 如果 resultLength和i 相加刚好等于letters.count - 1，就不需要再进行下面的遍历了。 // 因为此时的resultLength的长度是最长的了 if i + resultLength == (letters.count - 1) &#123; break &#125; &#125; return resultLength&#125; 3.2滑动窗口 1234567891011121314151617181920212223242526272829303132333435363738394041func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123; let n = s.count var letters: [String] = [] for char in s &#123; let tempStr: String = String.init(char) letters .append(tempStr) &#125; // 1.如果s长度 &lt;= 1 if s.count &lt;= 1 &#123; print(s) return s.count &#125; var set: [String] = Array.init(repeating: &quot;&quot;, count: letters.count) var start: Int = 0 // 起始位置 var end: Int = 0 // 结束位置 var maxLength: Int = 0 // 最大长度 while start&lt;n &amp;&amp; end&lt;n &#123; maxLength = (end - start + 1) &gt; maxLength ? (end - start + 1) : maxLength if set.contains(letters[end]) &#123; let index: Int = set.index(of: letters[end])! // 1.start移动到上次出现重复位置的后一位 start = index + 1 // 2.短遍历，将前面遍历完的字符串置为空 for i in tempStart..&lt;start &#123; if set[i] != &quot;&quot; &#123; set[i] = &quot;&quot; &#125; &#125; // 3.tempStart作用：记录上一次start位置 tempStart = start // 4.当发现重复字符，maxLength需要-1 maxLength = maxLength - 1 &#125; set[end] = letters[end] end = end + 1 print(&quot;start-\(start) end-\(end) maxLength-\(maxLength)&quot;) // 最终最大长度 resultLength = maxLength &gt; resultLength ? maxLength : resultLength &#125; return resultLength&#125; 四、小结暴力破解：时间复杂度o(n的平方)滑动窗口：时间复杂度o(n*一个常数)滑动窗口参考资料，这里边有详细图解 由于时间复杂度太高了，没有通过leetcode检测，超时了。😭12345// leetcode测试用例var s:String = &quot;&quot;for _ in 0..&lt;100 &#123; s .append(&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\&quot;#$%&amp;&apos;()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~ &quot;)&#125; 不同区间的耗时统计:0..&lt;10 - 284ms0..&lt;20 - 960ms0..&lt;50 - 5.7s0..&lt;100 - 20s ps：当区间为[0,100]，耗时简直恐怖。。。 —————————————分割线————————————-经过多方查找，和自己验证，果断找到了一种办法。 用hash值。因为每个字符只对应一个hash值。但是swift的这个值和c++或者java又有所不同。他们之间的差值不同。 验证:12345678910111213141516171819将所有字符都列出来，比较找出最大最小的hash值和对应的字符。var s:String = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\&quot;#$%&amp;&apos;()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~ &quot;var characters:[String] = []for char in s &#123; let string:String = String.init(char) characters.append(string)&#125;var max: Int = 0var min: Int = Int.maxfor i in 0..&lt;characters.count &#123; if (characters[i].hashValue &gt; max) &#123; max = characters[i].hashValue print(&quot;max:\(max), characters[i]:\(characters[i]) ,i:\(i)&quot;) &#125; if (characters[i].hashValue &lt; min) &#123; min = characters[i].hashValue print(&quot;min:\(min), characters[i]:\(characters[i]) ,i:\(i)&quot;) &#125;&#125; 结果：max: I 4799450059485597695min: _ 4799450059485595649差值：2046 然后就简单了，之前一直卡在越界问题上1234567891011121314151617181920212223242526func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123; var last:[Int] = Array.init(repeating: -1, count: 2047) var start: Int = 0 // 起始位置 var maxLength: Int = 0 // 最大长度 var characters:[String] = [] for char in s &#123; let string:String = String.init(char) characters.append(string) &#125; for i in 0..&lt;characters.count &#123; let hash_i: Int = characters[i].hashValue let hash_a: Int = &quot;_&quot;.hashValue if (last[hash_i - hash_a] &gt;= start) &#123; maxLength = max(maxLength, i-start) start = last[hash_i - hash_a] + 1 &#125; last[hash_i - hash_a] = i &#125; maxLength = max(maxLength, s.count - start) return maxLength&#125; 奇迹出现：耗时6ms！几千倍的差距。 然而leetcode还是没通过，说我越界了，我特么。。。自己运行没问题啊 然后我申诉了该题目。😏 —————————————分割线————————————- 在做387.字符串中的第一个唯一字符时，我发现了如果用hash值是会越界的，在leetcode上是会这样。那我们可以用ASCII码来搞，因为每一个字符只对应一个ASCII码。可以参照ASCII码对照表 123456789abcdefghijklmnopqrstuvwxyz 97~122ABCDEFGHIJKLMNOPQRSTUVWXYZ 65~900123456789 48~57!\&quot;#$%&amp;&apos;()*+,-./ 33~47:;&lt;=&gt;? 58~64@[\\]^_` 91~96&#123;|&#125;~ 123~126&quot; &quot; 32空字符 0 接下来，只要把hashValue换一下就OK了。123456// 所有字符的所对应的ASCII码，用CChar类型表示，实质为Int8类型。// 该方法末尾会默认加上一个&quot;0&quot;元素，也就是空字符var allCharacter: [Int8]? =&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\&quot;#$%&amp;&apos;()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~ &quot;.cString(using: String.Encoding.utf8)print(allCharacter)print(allCharacter?.count) 12345678910111213141516171819202122func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123; var last:[Int] = Array.init(repeating: -1, count: 127) var start: Int = 0 // 起始位置 var maxLength: Int = 0 // 最大长度 let chars: [Int8]? = s.cString(using: String.Encoding.utf8) for i in 0..&lt;s.count &#123; let hash_i: Int = Int(chars![i]) let hash_null: Int = 0 if (last[hash_i - hash_null] &gt;= start) &#123; maxLength = max(maxLength, i-start) start = last[hash_i - hash_null] + 1 &#125; last[hash_i - hash_null] = i &#125; maxLength = max(maxLength, s.count - start) return maxLength&#125; 后记这一题和387.字符串中的第一个唯一字符思路大致相同，不太清楚的可以先看一下那题。1.耗时44毫秒，超过99.35%的提交记录，总提交数987。 这一题总算告一段落了。大家有疑惑的地方欢迎一起探讨啊。😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[4. 两个排序数组的中位数]]></title>
    <url>%2F2018%2F07%2F09%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F4.%20%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。 二、题目意思剖析：1234567nums1 = [1, 3]nums2 = [2]中位数是 2.0nums1 = [1, 2]nums2 = [3, 4]中位数是 (2 + 3)/2 = 2.5 三、解题思路：1.先将数组排好序2.如果数组count是奇数，那中间那位数（count / 2）就是中位数。3.如果数组count是偶数，那中位数 = （第(count / 2) - 1 + 第(count / 2)）/ 2例子：[20、21、23、23、25、29、32]7 / 2 = 3，中位数 = 23[20、21、23、23、25、29、32、33]8 / 2 = 4，中位数 =（23+25）/ 21234567891011121314151617181920212223func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -&gt; Double &#123; var nums: [Int] = [] var result: Double = 0 for i in 0..&lt;nums1.count &#123; nums .append(nums1[i]) &#125; for i in 0..&lt;nums2.count &#123; nums .append(nums2[i]) &#125; nums.sort() print(nums) if nums.count % 2 == 0 &#123; //偶数 let num1: Int = nums[nums.count / 2 - 1] let num2: Int = nums[nums.count / 2] result = Double(Double(num1 + num2) / 2) &#125;else if nums.count % 2 != 0 &#123; // 奇数 result = Double(nums[nums.count / 2]) &#125; return result;&#125; 四、小结耗时172毫秒，超过5.88%的提交记录，总提交数2080。 其实这是想到的最简答的方法，耗时会偏长，大家有好的想法可以留言啊，我暂时就没去深究了，继续下题下题。。。 有任何疑问都可以留言，非常乐意一起探讨。😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2. 两数相加]]></title>
    <url>%2F2018%2F07%2F06%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。 二、题目意思剖析：将数字反过来，再相加，然后再逆序存起来。123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 三、解题思路：官方解析：1.将当前节点初始化为返回列表的哑节点。2.将进位 carry 初始化为 0。3.将 p 和 q 分别初始化为列表 l1 和 l2 的头部。4.遍历列表 l1和 l2 直至到达它们的尾端。5.将 x 设为节点 p 的值。如果 p 已经到达 l1的末尾，则将其值设置为0。6.将 y 设为节点 q 的值。如果 q 已经到达 l2 的末尾，则将其值设置为0。7.设定 sum=x+y+carry。更新进位的值，carry=sum/10。8.创建一个数值为 (sum余10) 的新节点，并将其设置为当前节点的下一个节点，然后将当前节点前进到下一个节点。9.同时，将 p 和 q 前进到下一个节点。检查 carry=1 是否成立，如果成立，则向返回列表追加一个含有数字 1 的新节点。返回哑节点的下一个节点。 我的理解：其实由繁化简来说，就是保存sum的余数和sum的除数，也就是看看它是否超过了10，这有一个特殊处理。比如 5 + 8 = 13，13 / 10 = 1，13 % 10 = 3。那其实就变成了3 -&gt; 1curr是先加余数，再加进位的那个1。 123456789// 1.链表构造public class ListNode &#123; public var val: Int public var next: ListNode? public init(_ val: Int) &#123; self.val = val self.next = nil &#125;&#125; 123456789101112131415161718192021222324252627func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123; let dummyHead: ListNode? = ListNode.init(0) var p: ListNode? = l1 var q: ListNode? = l2 var curr: ListNode? = dummyHead var carray: Int = 0 while (p != nil) || (q != nil) &#123; let x: Int = (p != nil) ? (p?.val)! : 0 let y: Int = (q != nil) ? (q?.val)! : 0 let sum: Int = carray + x + y carray = sum / 10 curr?.next = ListNode.init(sum % 10) curr = curr?.next if (p != nil) &#123; p = p?.next &#125; if (q != nil) &#123; q = q?.next &#125; &#125; if carray &gt; 0 &#123; curr?.next = ListNode.init(carray) &#125; return dummyHead?.next&#125; 四、小结有时候抓住关键点就可以一击突破。这题的关键就在于处理sum的余数和除数。 耗时120毫秒，超过38.75%的提交记录，总提交数1562。 有任何疑问都可以留言，非常乐意一起探讨。😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1. 两数之和]]></title>
    <url>%2F2018%2F07%2F06%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 二、题目意思剖析：从数组里找出两个数，加起来=目标值，返回两个数的位置。当然可能有非常多的两个数组合，所以需要将所有情况都返回。123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 三、解题思路：直接用两个for 循环暴力破解。1234567891011121314// 暴力破解法 : 时间复杂度O(n的平方) 空间复杂度O(1)，因为只创建了一次变量someInts。func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123; var someInts = [Int]() for i in 0..&lt;nums.count &#123; for j in i+1..&lt;nums.count &#123; if nums[i]+nums[j] == target &#123; someInts += [i] someInts += [j] &#125; &#125; &#125; return someInts&#125; 四、小结这题比较简单，从前往后数，相加之后进行比对。 耗时824毫秒，超过40.98%的提交记录，总提交数20。 有任何疑问都可以留言，非常乐意一起探讨。😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[17.电话号码的字母组合]]></title>
    <url>%2F2018%2F07%2F05%2FleetCode%E9%A2%98%E5%BA%93%E7%AC%94%E8%AE%B0%2F17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[一、题目原型： 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 二、题目意思剖析：其实呢就是一个排列组合，将字母按照有序的顺序组合起来。123456789101112131415/* 2-abc 3-def 4-ghi 5-jkl 6-mno 7-pqrs 8-tuv 9-wxyz 输入：&quot;23&quot; 输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 如果输入的是 245 输出：[&quot;agj&quot;, &quot;agk&quot;, &quot;agl&quot;, &quot;ahj&quot;, &quot;ahk&quot;, &quot;ahl&quot;, &quot;aij&quot;, &quot;aik&quot;, &quot;ail&quot;...... */ 三、解题思路：我呢是用swift语法来做，但是逻辑思路都是相通的。第一想到的应该是递归。通过递归，再加上一些判断条件，将对应的字符串加入进数组。1234567891011121314// 1.最外围的主方法func letterCombinations(_ digits: String) -&gt; [String] &#123; if digits.isEmpty &#123; return [] &#125; // 由于swift语法特性，需要将digits字符串包装为一个数组 var strings: [String] = [] for digit in digits &#123; let str: String = String.init(digit) strings .append(str) &#125; haha(strings,0) return result&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 2.核心代码实现func haha(_ strings: [String], _ index: Int) &#123; if str.count == strings.count &#123; result .append(str) return &#125; // 防止数组越界 if index &gt;= strings.count &#123; return &#125; // 1.首先我们需要一个电话号码base数组。 let bases: [[String]] = [[&quot;&quot;],[&quot;&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;],[&quot;g&quot;,&quot;h&quot;,&quot;i&quot;],[&quot;j&quot;,&quot;k&quot;,&quot;l&quot;],[&quot;m&quot;,&quot;n&quot;,&quot;o&quot;],[&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;],[&quot;t&quot;,&quot;u&quot;,&quot;v&quot;],[&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]] // 2.通过index索引将strings对应的字符串元素转换为Int类型的索引 // baseIndex : 电话号码(数字)索引,比如strings=[&quot;2&quot;,&quot;4&quot;,&quot;5&quot;],baseIndex就是2,4,5 let baseIndex: Int = (Int)(strings[index])! for i in 0..&lt;bases[baseIndex].count &#123; // 拿到子数组里对应的字母 let baseStr: String = bases[baseIndex][i] // 1.如果当前正在添加第一个字母,就将str清空 if index == 0 &#123; str .removeAll() &#125; /* 2.如果当前正在添加最后一个字母,并且不是第一个字母串,就删除str的最后一个字符 比如index = 2,说明在添加第三个字母，如果i不等于0，就需要把最后一个字母删除。 &quot;agj&quot;, &quot;agk&quot;, &quot;agl&quot; 过程 : agj - ag - agk - ag - agl */ else if index == strings.count - 1 &amp;&amp; i != 0&#123; str .removeLast() &#125; else &#123; // 3.如果str不为空，需要删除字母串的后面几位，通过index来设定 // 用str的长度 - index得到后面需要删除的长度 // &quot;jmpt&quot;, &quot;jmpu&quot;, &quot;jmpv&quot;, &quot;jmqt&quot;, &quot;jmqu&quot;, &quot;jmqv&quot;, &quot;jmrt&quot;, &quot;jmru&quot;, &quot;jmrv&quot;, &quot;jmst&quot;, &quot;jmsu&quot;, &quot;jmsv // 比如当前字符串为 jmrv，index为2，就需要删除后面 4 - 2 = 2，删除后面2位。 // baseStr为s，然后接下来的baseStr为t。 // 过程 : jmrv - jm - jms - jmst if !str.isEmpty &#123; str .removeLast(str.count - index) &#125; &#125; str .append(baseStr) haha(strings, index + 1) &#125;&#125; 四、小结有时候这类题都是去找规律，我们需要把一些例子所得到的数据展示出来，然后去寻找规律，让计算的过程直观的表达出来。注：可以在haha方法里加入一个indexs数组，result也不要限定条件来添加，然后直接在letterCombinations方法里打印出indexs和result的值。这样可以非常直观的查看添加过程。12345func haha(_ strings: [String], _ index: Int) &#123; indexs .append(index) result .append(str) 、、、后面的代码不变&#125; 耗时12毫秒，超过100%的提交记录，总提交数25。 有任何疑问都可以留言，非常乐意一起探讨。😄]]></content>
      <categories>
        <category>leetCode题库笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[东西涌穿越官方攻略]]></title>
    <url>%2F2018%2F06%2F11%2F%E6%97%85%E8%A1%8C%2F%E4%B8%9C%E8%A5%BF%E6%B6%8C%E7%A9%BF%E8%B6%8A%E5%AE%98%E6%96%B9%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[一、收拾行囊(物品准备)时间：最好在出发的前一天晚上准备好装备：1、穿戴： 帽子、头巾(围脖、护脸多功能使用)、护臂(直接淘宝搜护肘护臂)、手套(防滑的就行)、太阳镜(可以考虑带，很帅)、衣服带两套(长裤一条、短袖两件)、运动鞋一双、拖鞋一双(可以考虑带)、泳裤一条、沙滩裤(短裤)一条、不会游泳的那边有泳圈租10元一个、一把伞(防晒、防雨)2、药品：扭伤药系列(防止有人意外扭伤，及时处理)、花露水(要穿越树林和一些茂密的草丛，驱蚊止痒)、然后防晒霜啥的(男孩子就别带了，做好上面的穿戴就没事)。3、吃喝：1袋面包(不需要太多，5个就够了)、4个煌上煌鸭架(补充盐分)、4根黄瓜(4根真的不多，你相信那几根黄瓜是我吃过最好吃的黄瓜吗)、2瓶2元怡宝水、1瓶盐水 (注–以上说的吃喝，是一个人的分量哦，水最好都带冰的，解渴)4、报备：可以提前在网上报备，也可以现场报备，其实就是登记一下。 差不多就这些，如果还有遗漏的，再及时补充。 二、出发起点：早上5点半起床，洗漱收拾东西差不多10-15分钟，5:45在楼下直接拦了辆车（早上出租车还是挺多的），几分钟就到了深圳北站交通枢纽公交站。问了下路，坐E11路是在二楼。差不多在6点前就到了，这时是可以赶上第一班的。不过我那朋友迟到了，最后我们坐的6点半那车。定位目的地技巧：直接在百度地图搜索E11路，直接会有一个起点终点，找到深圳北站交通枢纽公交站，点击然后点击到这去，直接导航。从我民乐新村(地铁4号线民乐站附近)这到那边不到五公里，开车花了10分钟不到。 坐车：坐E11到 (南澳街道办站) 下车，然后在南澳街道办站等车。1.如果你要去东涌，就做M231，到终点站东涌浴场下车；2.如果去西涌，就做M232，到西涌三四号浴场下车（其实后面那几站都行，西涌海岸线简直太美了，又比较长，到哪下都行，不要去终点站西涌西贡村就行。）坐车时间：6点半上车，8点25到南澳街道办，南澳街道办坐车到东涌/西冲大概20-30分钟。总体时间：2个半小时左右。ps：最好下一个叫做“车来了”的app，这样方便很多。 三、路线建议：东涌 到 西涌到了南澳街道办，就直接坐M231去东涌。不要进去东涌浴场，切记切记！！！那里完全和西涌浴场没法比，只有西涌海岸线长的四分之一可能更少，价格却是20元一人，西涌是13。到了终点站，直接下车往东涌码头走，那边有一座桥，百度地图没更新，大概在这个位置。 桥的那边会有人守着，你需要登记一下(报备)。过桥沿着土路（能容纳一辆车的路）一直走，看到一个小亭子(铁皮房)，里面有人吹着空调(可能也不在)，不用管他。直接往左转上山，此时沿着路走你就开始穿越啦。 四、正式穿越时间控制：穿越时间3小时 穿越时间一般在3-5小时之间。我们是两个人(男孩)，行动力比较强，从报备登记完到目的地差不多花了3个小时，包括了中间休息的时间。中间休息大概在8-10次，每次3-5分钟，如果坚持不了，就找一个就近的地方休息，最好是有遮阴的地方。喝口水、多做深呼吸，慢慢走不要急。路就一直跟着海岸线走就行了，有些很陡峭，有些很平坦，在岩石上跳来跳去要小心，不要扭到脚，注意安全，如果队伍里有女生，最好有几个男孩子带着，慢慢走。放几张图，你们感受下。 有些困难，这样就会有挑战性，人活着就需要做一些自己不一定能完全做好的事，这样才会有意义，这段记忆会一直存储在你的记忆里，经久不息。 五、东西涌路线选择1、东西冲穿越：如果你要爬山穿越（很苦的，脚会很酸，有些地方很陡峭，要注意安全），累但是很有意义。2、如果不穿越，单纯的是想去海边玩玩，看看干净的海水，看看日出，踩着沙子看着心爱的人的笑容，那就完全可以直接坐M232去西涌。(海边小屋我问了，双人床一晚238，两张床一晚338，需要电话的话留言，我不是打广告的坚决不是，因为那个要提前预定，火爆期真的怕订不到。也可以自己带帐篷，在那搭着睡)西涌是真的好看，好几公里的海岸线，延绵无尽。海水清澈见底，沙子柔软，你可以光着脚踩着沙子慢慢走，也可以租一个太阳伞在那躺着坐着，一天感觉就会过得很缓慢，听着海浪的拍打声，陪着自己的家人开开心心的，一切就真的很美好，其实这就是幸福生活了吧。也是自己一个人偶尔放松放松、放空自己的非常好的去处。额，我不会游泳，怕吃海水，太特么咸了，学了很久也不会。喜欢游泳的在那呆上两天，你就知道那简直就是天堂。 ————————————我是分割线—————————————————— 前段时间家里人来深圳玩，我又去了一趟西冲，路线大致相同但也有些不同，再次分享下。 1.起点还是深圳北，时间是接近中午的时候。这次因为带着家人路途遥远，我们就在大棚中心站下的车，补充了能量吃了个午饭。在那公交站附近有一个华润万家超市，我们把很多多余的背包都存放在那了，免费的，你就说去买东西等下来拿😄。 2.然后坐M232，直接到达西冲一号浴场。然后租了几个游泳圈就过去了。然后发现人炒鸡多。。。这个时候是下午不到4点的时候。当然，海水依旧清澈，旁边时不时有人坐快艇过，一浪接一浪。有人冲浪、有人潜水。 3.然后我妈妈不打算住宿，我们玩了几个小时就打道回府了。差不多6点钟开始出发，折回大棚中心，取东西，然后等E11，8点半到了家，之后当然就是丰盛的晚餐咯。]]></content>
      <categories>
        <category>旅行</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS瀑布流之横-纵瀑布流]]></title>
    <url>%2F2018%2F06%2F08%2FiOS%E9%9A%8F%E7%AC%94%2FiOS%E7%80%91%E5%B8%83%E6%B5%81%E4%B9%8B%E6%A8%AA-%E7%BA%B5%E7%80%91%E5%B8%83%E6%B5%81%2F</url>
    <content type="text"><![CDATA[一、开篇1.瀑布流设计讨论 1.1.应用场景：在我们app开发中，瀑布流一般应用于大数据展示时，比如淘宝搜索页面、蘑菇街app、各大直播app主播列表页面等等。 1.2.设计思路：我们首要考虑UICollectionView,因为UICollectionView特殊性和可复用性。因为瀑布流每个格子item大小不同，需要计算每个item的宽高，就需要自定义UICollectionViewLayout。 2.瀑布流分类 我把瀑布流分为两种：垂直瀑布流、水平瀑布流。 2.1.垂直瀑布流：在我们app上实现的瀑布流一般是垂直瀑布流，也就是列数可设定，item宽度由列数决定，从上往下布局。 2.2.水平瀑布流：我在搜索网页百度图片时，看到百度图片的布局从而想到的一种布局方式。每行的高度是可设定的，item高度由图片大小决定，比例缩放。 3.瀑布流样式展示 二、具体实现1.创建一个UICollectionViewCell，它上面只有一个imageView。 12345678910// CollectionViewCell.m- (instancetype)initWithFrame:(CGRect)frame &#123; if (self = [super initWithFrame:frame]) &#123; _imageView = [[UIImageView alloc] init]; _imageView.frame = self.bounds; [self addSubview:_imageView]; &#125; return self;&#125; 2.我们需要自定义一个layout，并且暴露一些可设置的属性用来控制瀑布流的对应展示，让瀑布流可用性更强大一些。 2.1 头文件：DYTWaterflowLayout.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445@interface DYTWaterflowLayout : UICollectionViewLayout/** * 行高(水平瀑布流时),默认为100 */@property (nonatomic, assign) CGFloat rowHeight;/** * 单元格宽度(垂直瀑布流时) */@property (nonatomic, assign, readonly) CGFloat itemWidth;/** * 列数 : 默认为3 */@property (nonatomic, assign) NSInteger numberOfColumns;/** * 内边距 : 每一列之间的间距 (top, left, bottom, right)默认为&#123;10, 10, 10, 10&#125;; */@property (nonatomic, assign) UIEdgeInsets insets;/** * 每一行之间的间距 : 默认为10 */@property (nonatomic, assign) CGFloat rowGap;/** * 每一列之间的间距 : 默认为10 */@property (nonatomic, assign) CGFloat columnGap;/** * 高度数组 : 存储所有item的高度 */@property (nonatomic, strong) NSArray *itemHeights;/** * 宽度数组 : 存储所有item的宽度 */@property (nonatomic, strong) NSArray *itemWidths;/** * 瀑布流类型 : 分为水平瀑布流 和 垂直瀑布流 */@property (nonatomic, assign) DirectionType type;@end 2.2 .m文件：DYTWaterflowLayout.m属性声明 1234567891011121314151617@interface DYTWaterflowLayout()@property (nonatomic, strong) NSMutableArray *itemAttributes; // 存放每个cell的布局属性// 垂直瀑布流相关属性@property (nonatomic, strong) NSMutableArray *columnsHeights; // 每一列的高度(count=多少列)@property (nonatomic, assign) CGFloat maxHeight; // 最长列的高度(最大高度)@property (nonatomic, assign) CGFloat minHeight; // 最短列的高度(最低高度)@property (nonatomic, assign) NSInteger minIndex; // 最短列的下标@property (nonatomic, assign) NSInteger maxIndex; // 最长列的下标// 水平瀑布流相关属性@property (nonatomic, strong) NSMutableArray *columnsWidths; // 每一行的宽度(count不确定)@property (nonatomic, assign) NSInteger tempItemX; // 临时x : 用来计算每个cell的x值@property (nonatomic, assign) NSInteger maxRowIndex; //最大行@end 2.3 .m文件：DYTWaterflowLayout.m主要方法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// #pragma mark -- 系统内部方法/** * 重写父类布局 */- (void)prepareLayout &#123; [super prepareLayout]; // (水平瀑布流时)重置最大行 if ((self.type == HorizontalType)) &#123; self.maxRowIndex = 0; &#125; if (self.type == VerticalType) &#123; // (垂直瀑布流时)重置每一列的高度 [self.columnsHeights removeAllObjects]; for (NSUInteger i = 0; i &lt; self.numberOfColumns; i++) &#123; [self.columnsHeights addObject:@(self.insets.top)]; &#125; &#125; // 计算所有cell的布局属性 [self.itemAttributes removeAllObjects]; NSUInteger itemCount = [self.collectionView numberOfItemsInSection:0]; self.tempItemX = self.insets.left; for (NSUInteger i = 0; i &lt; itemCount; ++i) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForItem:i inSection:0]; if (self.type == VerticalType) &#123; [self setVerticalFrame:indexPath]; &#125;else if ((self.type == HorizontalType))&#123; [self setHorizontalFrame:indexPath]; &#125; &#125;&#125;/** * 水平瀑布：设置每一个attrs的frame，并加入数组中 */- (void)setHorizontalFrame:(NSIndexPath *)indexPath &#123; UICollectionViewLayoutAttributes *attrs = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; CGFloat w = [self.itemWidths[indexPath.item] floatValue]; CGFloat width = w + self.columnGap; CGFloat h = (self.rowHeight == 0) ? 100 : self.rowHeight; /** * 如果当前的x值+当前cell的宽度 超出了 屏幕宽度，那么就要换行了。 * 换行操作 : 最大行+1，tempItemX重置为10(self.insets.left)。 */ if (self.tempItemX + w &gt; [UIScreen mainScreen].bounds.size.width) &#123; self.maxRowIndex++; self.tempItemX = self.insets.left; &#125; CGFloat x = self.tempItemX; CGFloat y = self.insets.top + self.maxRowIndex * (h + self.rowGap); attrs.frame = CGRectMake(x, y, w, h); /** * 注：1.cell的宽度和高度算起来比较简单 : 宽度由外部传进来，高度固定为rowHeight(默认为100)。 * 2.cell的x : 通过tempItemX算好了。 * 3.cell的y : minHeight最短列的高度，也就是最低高度，作为当前cell的起始y，当然要加上行之间的间隙。 */ NSLog(@&quot;%@&quot;,NSStringFromCGRect(attrs.frame)); [self.itemAttributes addObject:attrs]; self.tempItemX += width;&#125;/** * 垂直瀑布：设置每一个attrs的frame，并加入数组中 */- (void)setVerticalFrame:(NSIndexPath *)indexPath &#123; UICollectionViewLayoutAttributes *attrs = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; // cell的frame CGFloat w = self.itemWidth; CGFloat h = [self.itemHeights[indexPath.item] floatValue]; CGFloat x = self.insets.left + self.minIndex * (w + self.columnGap); CGFloat y = self.minHeight + self.rowGap; attrs.frame = CGRectMake(x, y, w, h); /** * 注：1.cell的宽度和高度算起来比较简单 : 宽度固定(itemWidth已经算好)，高度由外部传进来 * 2.cell的x : minIndex最短列作为当前列。 * 3.cell的y : minHeight最短列的高度，也就是最低高度，作为当前cell的起始y，当然要加上行之间的间隙。 */ // 更新数组中的最大高度 self.columnsHeights[self.minIndex] = @(CGRectGetMaxY(attrs.frame)); NSLog(@&quot;%@&quot;,NSStringFromCGRect(attrs.frame)); [self.itemAttributes addObject:attrs];&#125;/** * 返回collectionView的尺寸 */- (CGSize)collectionViewContentSize &#123; CGFloat height; if (self.type == HorizontalType) &#123; CGFloat rowHeight = (self.rowHeight == 0) ? 100 : self.rowHeight; height = self.insets.top + (self.maxRowIndex+1) * (rowHeight + self.rowGap); &#125;else &#123; height = self.maxHeight; &#125; return CGSizeMake(self.collectionView.frame.size.width, height);&#125;/** * 所有元素（比如cell、补充控件、装饰控件）的布局属性 */- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect&#123; return self.itemAttributes;&#125; 3.1 直接在控制器里使用 12345678910// 设置布局DYTWaterflowLayout *layout = [[DYTWaterflowLayout alloc]init];layout.type = _type;// 设置相关属性(不设置的话也行，都有相关默认配置)layout.numberOfColumns = 3;layout.columnGap = 10;layout.rowGap = 10;layout.insets = UIEdgeInsetsMake(10, 10, 10, 10);layout.rowHeight = 100;self.collectionView.collectionViewLayout = self.waterflowLayout = layout; 3.2 (举例)垂直瀑布流时，SDWebImage获取图片block里的具体实现 12345678910111213if (weakSelf.heights.count &lt; weakSelf.allImageUrls.count) &#123; // 根据图片原始比例 计算 当前图片的高度(宽度固定) CGFloat scale = image.size.height / image.size.width; CGFloat width = weakSelf.waterflowLayout.itemWidth; CGFloat height = width * scale; NSNumber *heightNum = [NSNumber numberWithFloat:height]; [weakSelf.heights addObject:heightNum];&#125;if (weakSelf.heights.count == weakSelf.allImageUrls.count) &#123; // 赋值所有cell的高度数组itemHeights weakSelf.waterflowLayout.itemHeights = weakSelf.heights; [weakSelf.collectionView reloadData];&#125; 3.3 UICollectionViewDataSource中要注意的点 12345678- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123; CollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:reuseIdentifier forIndexPath:indexPath]; cell.imageView.image = self.picImageArr[indexPath.item]; // 注：非常关键的一句，由于cell的复用，imageView的frame可能和cell对不上，需要重新设置。 cell.imageView.frame = cell.bounds; cell.backgroundColor = [UIColor orangeColor]; return cell;&#125; 三、总结1.瀑布流使用场景比较广泛，也是常用的技术之一，我也是又回顾了一遍，并且总结了整体的思路决定分享出来，结尾有demo，童鞋们可以自行下载。另外我参考的资料链接也会贴出，供大家研究比对。2.水平瀑布流还没达到百度图片搜索的那种效果，右边距离屏幕间隙太大了，所以影响美观。后续会继续研究，期待有所突破。3.有种情况是后台直接给图片的所有数据给我们，包括url、图片宽高等等，其实这样就是后台已经做好了图片的顺序优化处理。不过我们可以自己研究一下这个排序思路。如何达到右边间隙几乎相同，比如都为10。4.当然有疑惑的地方可以留言或者直接私信我，我们可以一起讨论。 四、总结最终实现效果: 本文章demo：瀑布流Demo参考相关文章：iOS–瀑布流的实现 – 作者Go_SpeciOS 瀑布流基本实现 – 作者iOS_成才录 额。。。如果想知道图片里的小姐姐是谁，请直接在文章下面留言。因为我想暂时留点悬念给大家。(皮一下就很开心😄)]]></content>
      <categories>
        <category>iOS随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UITableViewCell的高度自适应浅析]]></title>
    <url>%2F2018%2F05%2F22%2FiOS%E9%9A%8F%E7%AC%94%2FUITableViewCell%E7%9A%84%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[—开篇：在我们开发中经常会用到UITableView, TableView上面的cell有时候非常复杂，高度可变、结构可变等等。那么这个时候我们该如何去自适应cell的高度呢。 一.通过frame去计算 第一种大家比较容易想到的方法，就是由上往下依次计算控件的frame，再将最下面的控件frame的最大y值拿到，赋值给整个cell_height，得到整个cell的最终高度。 简单布局的就可直接计算，但，如果复杂一些，结构多变，就需要另外创建一个frameModel来专门计算和存储cell的frame。这种情况逻辑复杂，也比较容易出错。 ######需要创建两个模型：model(存储数据)、frameModel(存储cell上子view的frame) 两者间的关系：frameModel是通过model来进行设置的，通过传入的model中的属性，来判断cell中子view显示或隐藏，从而一步一步得到所有的子view的frame值，最后，将cell的高度保存起来。 1234567// model.h@interface Model : NSObject@property (nonatomic, copy) NSString *name; //昵称@property (nonatomic, copy) NSString *icon; //头像@end 12345678910111213// FrameModel.h@class Model;@interface FrameModel : NSObject/** 数据模型 */@property (nonatomic, strong) Model *model;/** 头像frame */@property (nonatomic, assign, readonly) CGRect iconViewF;/** 昵称frame */@property (nonatomic, assign, readonly) CGRect nameLabelF;/** cell的高度 */@property (nonatomic, assign, readonly) CGFloat cellHeight; 123456789101112131415161718192021222324252627282930// FrameModel.m- (void)setModel:(Model *)model &#123; _model = model; CGFloat screen_Width = [UIScreen mainScreen].bounds.size.width; // cell的宽度 CGFloat cellW = screen_Width; // cell的边框宽度 CGFloat cellBorderW = 10; // cell之间的间距 CGFloat cellBorderMargin = 15; // 1.头像 CGFloat iconWH = 35; CGFloat iconX = cellBorderW; CGFloat iconY = cellBorderW; _iconViewF = CGRectMake(iconX, iconY, iconWH, iconWH); // 2.昵称 CGFloat nameX = CGRectGetMaxX(self.iconViewF) + cellBorderW; CGFloat nameY = iconY; CGSize nameSize = [model.name sizeWithFont:[UIFont systemFontOfSize:15]]; _nameLabelF = (CGRect)&#123;&#123;nameX,nameY&#125;,nameSize&#125;; // 13.cell的宽度 _cellHeight = CGRectGetMaxY(self.nameLabelF) + cellBorderMargin;&#125; 1234567// cell.h@class FrameModel;@interface Cell : UITableViewCell+ (Cell *)cellWithTableView:(UITableView *)tableView;/** frame模型 */@property (nonatomic, strong) FrameModel *frameModel; 1234567891011121314// cell.m- (void)setFrameModel:(FrameModel *)frameModel &#123; _frameModel = frameModel; Model *model = frameModel.model; // 头像 self.iconView.frame = frameModel.iconViewF; [self.iconView sd_setImageWithURL:[NSURL URLWithString:model.icon]]; // 昵称 self.nameLabel.frame = frameModel.nameLabelF; self.nameLabel.text = model.name;&#125; 这一步步走下来应该非常直观的。最后也就只有一步了，将拿到的数据进行model和frameModel之间的转换。 12345678910111213/** * 将Model模型转为FrameModel模型 */- (NSArray *)frameModelsWithStatuses:(NSArray *)models &#123; NSMutableArray *frames = [NSMutableArray array]; for (Model *model in models) &#123; FrameModel *frame = [[FrameModel alloc] init]; frame.model = model; [frames addObject:frame]; &#125; return frames;&#125; 接下来就是数据展示咯，将frameModel导入进cell里面就OK了。 这其实是一种分离思路，将各个模块分离化，逻辑会清晰很多，对于复杂的数据和UI异常适合。 额，其中有一个sizeWithFont，是我创建的一个分类，只是为了简化代码。12345678910111213141516// NSString+Extension.m- (CGSize)sizeWithFont:(UIFont *)font maxW:(CGFloat)maxW &#123; NSMutableDictionary *attrs = [NSMutableDictionary dictionary]; attrs[NSFontAttributeName] = font; CGSize maxSize = CGSizeMake(maxW, MAXFLOAT); NSString *version = [UIDevice currentDevice].systemVersion; if ([version doubleValue] &gt; 7.0) &#123; return [self boundingRectWithSize:maxSize options:NSStringDrawingUsesLineFragmentOrigin attributes:attrs context:nil].size; &#125;else &#123; return [self sizeWithFont:font constrainedToSize:maxSize]; &#125;&#125;- (CGSize)sizeWithFont:(UIFont *)font &#123; return [self sizeWithFont:font maxW:MAXFLOAT];&#125; 二.通过自动布局自动适配（推荐使用）1.在cell中，setModel方法中所做的事情只是将数据导入view中进行展示，其他都不用管。label的话需要设定preferredMaxLayoutWidth属性。12345678910111213// cell.m- (void)setModel:(Model *)model &#123; _model = model; // 头像 [self.iconView sd_setImageWithURL:[NSURL URLWithString:model.icon]]; // 昵称 self.nameLabel.text = model.name; CGFloat screen_Width = [UIScreen mainScreen].bounds.size.width; CGFloat width = screen_Width - 35 - 5; // label的宽度 // 自动布局：设定label文字的最大宽度,这个宽度也可以通过外部进行传递，从而设定。 self.nameLabel.preferredMaxLayoutWidth = width;&#125; 2.在获取cellHeight代理方法中，因为可能无法获取到当前的cell，我们的目的只是要得到cell的高度，所以在这我们创建了一个临时变量cell，用来计算cellHeight。1234567- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; self.cell.nameLabel.text = nil; self.cell.model = self.models[indexPath.row]; // cell进行自动布局，可以得到cellHeight CGFloat cellHeight = [self.cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height+1; return cellHeight&gt;31.0f? cellHeight:31.0f;&#125; 后记：如果有些需求是想得到tableview最大的高度，让cell完全展示出来，可以监听tableView的contentSize属性。注：iOS10以下，监听contentSize属性；iOS10及以上监听scrollView.contentSize属性。123456float iOS_version = [[[UIDevice currentDevice] systemVersion] floatValue];if (iOS_version &gt;= 8.0 &amp;&amp; iOS_version &lt; 10.0) &#123; [self.tableView addObserver:self forKeyPath:@&quot;contentSize&quot; options:NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew context:nil];&#125;else if (iOS_version &gt;= 10.0) &#123; [self.tableView addObserver:self forKeyPath:@&quot;scrollView.contentSize&quot; options:NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew context:nil];&#125; 123456789101112131415161718192021- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; float iOS_version = [[[UIDevice currentDevice] systemVersion] floatValue]; if (iOS_version &gt;= 8.0 &amp;&amp; iOS_version &lt; 10.0) &#123; if ([keyPath isEqualToString:@&quot;contentSize&quot;] &amp;&amp; object == self.tableView) &#123; CGSize size = [[change objectForKey:@&quot;new&quot;] CGSizeValue]; CGFloat height = size.height; //得到tableview的高度。 if(self.viewHeightBlock)&#123; self.viewHeightBlock(height); &#125; &#125; &#125;else if (iOS_version &gt;= 10.0) &#123; if ([keyPath isEqualToString:@&quot;scrollView.contentSize&quot;] &amp;&amp; object == self.tableView) &#123; CGSize size = [[change objectForKey:@&quot;new&quot;] CGSizeValue]; CGFloat height = size.height; if(self.viewHeightBlock)&#123; self.viewHeightBlock(height); &#125; &#125; &#125;&#125; 看到这里，或许你挥一挥衣袖，只留下了一个赞。😄]]></content>
      <categories>
        <category>iOS随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[APP基础功能的配置管理之系统权限控制]]></title>
    <url>%2F2018%2F04%2F19%2FiOS%E9%9A%8F%E7%AC%94%2FAPP%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E4%B9%8B%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[开篇：在iOS系统上，对于系统权限、用户权限的审核是非常严格的。 比如相机、相册、麦克风、通讯录、定位和蓝牙等，在app线上审核时，如果你没用到其中的权限，但是在info.plist里设置了，就会被拒。 所以接下来，我整理了目前版本的Xcode(9.2)里所有的权限控制及解释 NSBluetoothPeripheralUsageDescription — 访问蓝牙NSCalendarsUsageDescription — 访问日历NSCameraUsageDescription — 访问相机NSContactsUsageDescription — 访问通讯录NSFaceIDUsageDescription — 访问FaceID，面部识别NSHealthShareUsageDescription — 访问健康分享NSHealthUpdateUsageDescription — 访问健康更新NSHomeKitUsageDescription — 访问智能家居 NSLocationAlwaysAndWhenInUseUsageDescription — 在使用期间始终访问位置NSLocationWhenInUseUsageDescription — 在使用期间访问位置NSLocationAlwaysUsageDescription — 始终访问位置NSLocationUsageDescription — 访问位置 NSAppleMusicUsageDescription — 访问媒体资料库 — Privacy - Media Library Usage Description（key和描述不太一样） NSMicrophoneUsageDescription — 麦克风NSMotionUsageDescription — 运动使用权限kTCCServiceMediaLibrary — 访问音乐权限 — Privacy - Music Usage Description（key和描述不太一样）NFCReaderUsageDescription — NFC权限 — Privacy - NFC Scan Usage Description（key和描述不太一样） NSPhotoLibraryAddUsageDescription — 添加内容到相册 — Privacy - Photo Library Additions Usage Description（key和描述不太一样）NSPhotoLibraryUsageDescription — 访问相册 NSRemindersUsageDescription — 访问提醒事项NSSiriUsageDescription — 访问SiriNSSpeechRecognitionUsageDescription — 语音识别 NSVideoSubscriberAccountUsageDescription — 电视供应商使用权限Privacy - TV Provider Usage Description 、Privacy - Video Subscriber Account Usage Description最后两项是相同的。 注：到目前为止一共是24项，但是最后两项是相同的，有一个被弃用了，所以只有23项。 相关文章：APP基础功能的配置管理之ATSAPP基础功能的配置管理之URL Scheme和白名单APP基础功能的配置管理之屏幕旋转控制]]></content>
      <categories>
        <category>iOS随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[APP基础功能的配置管理之屏幕旋转控制]]></title>
    <url>%2F2018%2F04%2F19%2FiOS%E9%9A%8F%E7%AC%94%2FAPP%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E4%B9%8B%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言：1.屏幕分为：横竖屏。2.在苹果系统中，分为4个类型：Portrait(竖直正方向)、Upside Down(竖直倒转方向)、 LandscapeLeft(左)、LandscapeRight(右)一般情况下，我们创建一个app，系统默认选择的是1、3、4方向，倒转方向用的很少，如果需要使用2方向，即竖直倒转方向，除了info.plist设置之外，还需在视图控制器里设置shouldAutorotate为NO; 1234// 是否默认旋转- (BOOL)shouldAutorotate &#123; return NO;&#125; 横屏用的地方也比较多，比如视频app从竖屏切到横屏全屏观看模式，再比如某些app的横屏页面板块。这就需要进行页面的横屏设置了。 这里还涉及到一个跳转问题，iOS页面跳转分为模态视图跳转Modal Presentation和通过导航栏的跳转 1.通过模态视图跳转，只需要在destination控制器里加上以下代码配置。123456789101112- (BOOL)shouldAutorotate &#123; return NO;&#125;- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation &#123; return toInterfaceOrientation == UIInterfaceOrientationLandscapeRight;&#125;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123; return UIInterfaceOrientationLandscapeRight;&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123; return UIInterfaceOrientationMaskLandscapeRight;&#125; 2.通过导航栏的跳转push到下个控制器在Appdelegate.h里添加外部属性1@property(nonatomic,assign)BOOL allowRotation; //是否允许转向 在Appdelegate.m里设定整个app的Orientation属性。12345678910- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(nullable UIWindow *)window &#123; if (self.allowRotation == YES) &#123; //横屏 return UIInterfaceOrientationMaskLandscape; &#125;else&#123; //竖屏 return UIInterfaceOrientationMaskPortrait; &#125;&#125; 在目标控制器里，12345AppDelegate * appDelegate = (AppDelegate *)[UIApplication sharedApplication].delegate;//允许转成横屏appDelegate.allowRotation = YES;//调用横屏代码[UIDevice switchNewOrientation:UIInterfaceOrientationLandscapeRight]; //设定切换模式，如果在手机里取消了屏幕旋转锁定，那么横屏时就会根据手机的放置方向而自动旋转。 相关文章：APP基础功能的配置管理之ATSAPP基础功能的配置管理之URL Scheme和白名单APP基础功能的配置管理之系统权限控制]]></content>
      <categories>
        <category>iOS随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[APP基础功能的配置管理之URL Scheme和白名单]]></title>
    <url>%2F2018%2F04%2F19%2FiOS%E9%9A%8F%E7%AC%94%2FAPP%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E4%B9%8BURL-Scheme%E5%92%8C%E7%99%BD%E5%90%8D%E5%8D%95%2F</url>
    <content type="text"><![CDATA[一、URL Scheme相信大家都知道 URL，例如 http://www.jianshu.com/就是一个URL。在 :// 之前的部分就称为 URL Scheme。也就是说 http://www.jianshu.com/ 的 URL Scheme 就是 http URL Scheme 就是一个可以让 app 相互之间可以跳转的协议 1.打开Mail[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@”mailto:frank@wwdcdemo.example.com“]] 2.打开电话[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@”tel:10086”]]; 3.打开SMS[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@”sms:10086”]]; 4.通过自定义 URL Scheme 向应用传递参数举例：支付宝的URL Scheme ：alipay2018081200218976://safepay/?{“memo”:{“result”:””,”ResultStatus”:”6001”,”memo”:”用户中途取消”},”requestType”:”safepay”} 二、白名单1.实际项目里用到的常见白名单。 2.自定义白名单。白名单一般是和URL Scheme结合使用的。比如app_A想打开app_B，app_B的URL Schemes是haha。 我们就需要在app_A里的info.plist添加白名单。 废话不多说，直接上代码（app_A里写）1234567891011121314- (void)clickBtn &#123; NSString *urlString = @&quot;haha://&quot;; // 若有中文传输需要进行转义 NSString *customURL = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]]; // 检查自定义 URL 是否被定义，如果定义了，则使用 shared application 实例来打开 URL if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:customURL]]) &#123; // openURL: 方法启动应用并将 URL 传入应用，在此过程中，当前的应用进入后台 [[UIApplication sharedApplication] openURL:[NSURL URLWithString:customURL]]; &#125; else &#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;URL error&quot; message:[NSString stringWithFormat:@&quot;No custom URL defined for %@&quot;, customURL] delegate:self cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil]; [alert show]; &#125;&#125; 1234后记：1.每个app的 URL Scheme 都是不一样的，如果存在一样的 URL Scheme，那么系统就会响应先安装那个app的 URL Scheme，因为后安装的app的 URL Scheme 被覆盖掉了，是不能被调用的。2.所以这里存在一个漏洞。比如app_A想打开app_B，但是app_C的 URL Scheme和app_B的一样，而且它比app_B先安装。那就永远调不起app_B，除非将app_C卸载。3.所以自己公司的URLScheme取名时尽量复杂些，这样别人想调起你app的难度就大大增加了。 相关文章：APP基础功能的配置管理之ATSAPP基础功能的配置管理之屏幕旋转控制APP基础功能的配置管理之系统权限控制]]></content>
      <categories>
        <category>iOS随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[APP基础功能的配置管理之ATS]]></title>
    <url>%2F2018%2F04%2F19%2FiOS%E9%9A%8F%E7%AC%94%2FAPP%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E4%B9%8BATS%2F</url>
    <content type="text"><![CDATA[一、TLS的历史 1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。1996年，SSL 3.0版问世，得到大规模应用。1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS（Transport Layer Security） 1.0版。2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。 二、Xcode中info.plist相关字段含义123456789101112131415161718192021222324252627&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoadsInMedia&lt;/key&gt; &lt;false/&gt; &lt;key&gt;NSAllowsLocalNetworking&lt;/key&gt; &lt;false/&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;false/&gt; &lt;key&gt;NSAllowsArbitraryLoadsInWebContent&lt;/key&gt; &lt;false/&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;www.app.youCompany.cn&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSExceptionMinimumTLSVersion&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSExceptionRequiresForwardSecrecy&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSRequiresCertificateTransparency&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/dict&gt; NSAllowsArbitraryLoads ： 默认为NO。如果设置为YES，将解除ATS限制，将会引发苹果的审查。一般设置为NO，然后通过下面的NSExceptionDomains去添加白名单（或者叫例外）。 NSAllowsArbitraryLoadsInMedia ： 默认为NO。如果设置为YES，将解除AVFoundation访问媒体内容时的ATS限制。 NSAllowsArbitraryLoadsInWebContent ： 默认为NO。如果设置为YES，将解除网页访问时的ATS限制。 NSAllowsLocalNetworking： 默认为NO。如果设置为YES，将解除访问本地资源时的ATS限制。 NSExceptionDomains : 添加例外 NSIncludesSubdomains ： 默认为NO。如果设置为YES，当前域名的 ATS 策略适用于其所有子域名。 NSExceptionAllowsInsecureHTTPLoads： 默认为NO。如果设置为YES，可以同时通过 HTTP 和 HTTPS 访问当前域名。（将会引发苹果的审查，上线时需要说明原因） NSExceptionMinimumTLSVersion： string类型，可以设置 TLS 最低版本。（因为低版本有安全漏洞，将会引发苹果的审查，上线时需要说明原因） NSExceptionRequiresForwardSecrecy： 默认为YES。如果设置为NO，允许针对当前域名使用不支持正向保密的 TLS 加密算法。 NSRequiresCertificateTransparency： 默认为NO。如果设置为YES，将验证域名服务器证书的Certificate Transparency时间戳 。 提交审核说明(举例)： 必须连接由其他机构控制的服务器，其还不支持安全连接。 必须通过 web 展示来源不一的各种网络内容，但又不能完全使用NSAllowsArbitraryLoadsInWebContent所管理的类。 必须支持那些还未升级至可使用安全连接，不得不通过公共域名访问网络的设备。 1后记：因最近公司需要我们整理一些自己在工作中用到的基础知识，特此整理搜集了一些笔记，放入简书供大家学习探讨。 相关文章：APP基础功能的配置管理之URL Scheme和白名单APP基础功能的配置管理之屏幕旋转控制APP基础功能的配置管理之系统权限控制]]></content>
      <categories>
        <category>iOS随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[QBImagePickerController导航栏的设置]]></title>
    <url>%2F2018%2F01%2F31%2FiOS%E9%9A%8F%E7%AC%94%2FQBImagePickerController%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%9A%84%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[开篇：想必大家对QBImagePickerController是非常熟悉的吧，至于怎么用很简答，网上、简书上有各位大神说的很详细。在此，我要说一个小知识，一不小心，思考方向走错了，可能会花上一两个小时哦。 一、我的困惑 1.它是否有导航栏，熟悉的同学都知道我们跳转QBImagePickerController时，都是直接present，是模态视图之间的跳转，而并不是push过去的。而且我们看到的QBImagePickerController的导航栏都是透明的。那么，我们就会考虑，它是否真的有导航栏呢。 验证我的想法：11.[imagePickerController.navigationController.navigationBar setBackgroundColor:[UIColor redColor]]; 12.imagePickerController.view.backgroundColor = [UIColor redColor]; 通过上面的两种方法都毫无效果，使我更加走进了一个误区，我认定QBImagePickerController没有导航栏。那么我猜想他头部的控件该是自定义的了，应该要暴露设置的参数给我，可惜我找了几遍，都没有。 二、刨根问底，直接进入pod里面的QBImagePickerController目录下 一看之下，才知道QBImagePickerController确实有导航控制器，不过是系统的UINavigationController，导航栏的背景颜色为空。我直接将storyboard里的UINavigationController类改成我自定义的导航控制器。问题引刃而解。 结语：有时候我们思考问题会走弯路，写这篇小知识，是希望自己走过的弯路提前告诉大家，给碰到问题的同学一点小帮助。]]></content>
      <categories>
        <category>iOS随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UITableView代理和数据源调用的先后顺序规律探究]]></title>
    <url>%2F2018%2F01%2F29%2FiOS%E9%9A%8F%E7%AC%94%2FUITableView%E4%BB%A3%E7%90%86%E5%92%8C%E6%95%B0%E6%8D%AE%E6%BA%90%E8%B0%83%E7%94%A8%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F%E8%A7%84%E5%BE%8B%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[开篇：因为某些原因和朋友讨论到，tableView在不同的iOS版本中，调用的先后顺序有所不同。特此，我利用相同的代码，在三种版本的模拟器中运行，果然得出了一些特定的规律。 我设置的数据源有1个section、30行，屏幕完全显示为22行。 iOS11.0123456789101112131415numberOfSectionsInTableViewheightForHeaderInSectionheightForFooterInSection （这四个方法一共调用三次，顺序和此列表显示一样）numberOfRowsInSectioncellForRowAtIndexPath heightForRowAtIndexPath ….…. (22-5 = 17行)heightForHeaderInSectionheightForFooterInSection （在倒数第五行，经测试5是固定的值）…. cellForRowAtIndexPath heightForRowAtIndexPath （剩余的5行，和上面的17行是相同的）…. iOS9.0、iOS10.0123456789101112131415161718这些方法一共调用三次，顺序和此列表显示一样numberOfSectionsInTableViewheightForHeaderInSectionheightForHeaderInSectionheightForFooterInSectionheightForFooterInSectionnumberOfRowsInSectionheightForRowAtIndexPath….…. (30行)….cellForRowAtIndexPath heightForRowAtIndexPath….…. (22行)…. 123456789101112注：iOS9.0、iOS10.0中就算以下两个方法都没有实现self.tableView.sectionHeaderHeight = 20;self.tableView.sectionFooterHeight = 20;heightForHeaderInSection和heightForFooterInSection都会调用iOS11.0中以下两个方法都没有实现self.tableView.sectionHeaderHeight = 20;self.tableView.sectionFooterHeight = 20;heightForHeaderInSection和heightForFooterInSection不会调用 结语：iOS11.0之后对tableview的数据源调用有了很大改变，节省了很多调用成本。更加合理规范化。所以如果有同学在获取不到数据源等等问题时，可以考虑本文所写的调用顺序，从而查找原因。​]]></content>
      <categories>
        <category>iOS随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS内购之二次验证]]></title>
    <url>%2F2018%2F01%2F25%2FiOS%E9%9A%8F%E7%AC%94%2FiOS%E5%86%85%E8%B4%AD%E4%B9%8B%E4%BA%8C%E6%AC%A1%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[开篇：关于iOS内购整体流程网上能找到很多。我抽丝剥茧，着重说一下二次验证及收据回传的数据问题。 二次验证关于二次验证，其实有两种做法，第一种是在app端验证，第二种也是安全防盗的一种，在服务端进行验证。具体区别不一一表述，可以查看下面的链接。iOS二次验证两种做法的区别我要着重说的是二次验证的实际做法和收到的数据是什么。 一、二次验证具体如何验证在这分为测试地址和实际上线地址测试：https://sandbox.itunes.apple.com/verifyReceipt已上线Appstore：https://buy.itunes.apple.com/verifyReceipt在沙箱测试时，我们使用测试地址。 123456// 从沙盒中获取交易凭证(收据)NSURL *receiptUrl = [[NSBundle mainBundle] appStoreReceiptURL];NSData *receiptData = [NSData dataWithContentsOfURL:receiptUrl]; // 转化为base64字符串NSString *receiptString = [receiptData base64EncodedStringWithOptions:0]; 为了方便拿到数据，我们在app端上进行验证，注意⚠️实际开发中都是在服务端进行验证的。1234567891011121314151617181920// 拼接请求数据NSString *bodyString = [NSString stringWithFormat:@&quot;&#123;\&quot;receipt-data\&quot; : \&quot;%@\&quot;&#125;&quot;, receiptString];NSData *bodyData = [bodyString dataUsingEncoding:NSUTF8StringEncoding];// 创建请求到苹果官方进行购买验证NSURL *url = [NSURL URLWithString:verifyReceipt_url];NSMutableURLRequest *requestM = [NSMutableURLRequest requestWithURL:url];requestM.HTTPBody = bodyData;requestM.HTTPMethod = @&quot;POST&quot;;// 创建连接并发送同步请求NSError *error = nil;NSData *responseData = [NSURLConnection sendSynchronousRequest:requestM returningResponse:nil error:&amp;error];if (error) &#123; NSLog(@&quot;验证购买过程中发生错误，错误信息：%@&quot;,error.localizedDescription); return;&#125;NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:responseData options:NSJSONReadingAllowFragments error:nil]; 二、收据回传得到的数据分析上文得到的dic就是我们通过收据得到的所有数据在这里有个坑，我相信有很多同学都踩过。就是你支付成功了，但是在这个数组里却找不到你想要的数据。我们可以看下面一张图，然后再分析分析。 可以看到有四种类型，但是具体到我们项目中我们该如何选择和操作呢。 1.消耗型：比如我们游戏里的金币，6元600个金币，你使用完了就失效了。比如现在各大视频app推出的电影购买，6元买完一张影片之后，你如果想买下一张影片就必须再次购买。2.非消耗型：比如某app推出永久会员，购买一次终身使用，就是非消耗型。再比如游戏过关时app的某关，你一直过不去，花钱购买过去了，等你下次再打开app时，他这关默认是已经通过的。3.自动续订型：具体可以看爱奇艺视频开通会员（腾讯app也类似），里面就有一个自动续订会员。也就是到期了，它会自动从你的苹果账号上扣钱。这个慎点慎点，他们这样搞很坑钱。4.非自动续订型：这个就是1个月优酷会员啦，或者3个月季度会员啥的。有期限，到期时也不会自动扣钱。一般的都是选择这个，不然像爱奇艺的自动续订，用户不知情时，会被骂死，哈哈 说了这么多，来看看订单数据长啥样12345678910111213&#123; product_id = &quot;lalalalahahaha&quot;,//商品的标识，和产品定，随便写但是不能重复 quantity = &quot;1&quot;,//购买商品的数量 transaction_id = &quot;1000000357637984&quot;,//交易的标识 purchase_date_ms = &quot;1512613065000&quot;,//购买时间毫秒 original_purchase_date_pst = &quot;2017-12-06 18:17:45 America/Los_Angeles&quot;,//购买时间,太平洋标准时间 purchase_date_pst = &quot;2017-12-06 18:17:45 America/Los_Angeles&quot;,//太平洋标准时间 original_purchase_date_ms = &quot;1512613065000&quot;,//毫秒 is_trial_period = &quot;false&quot;, original_purchase_date = &quot;2017-12-07 02:17:45 Etc/GMT&quot;,//原始购买时间 original_transaction_id = &quot;1000000357637984&quot;,//原始交易ID purchase_date = &quot;2017-12-07 02:17:45 Etc/GMT&quot;//购买时间&#125;, 我们得到的字典里如果有多条数据，就会有一个数组in_app。如果只有一条数据，或者没有数据，就没有in_app。in_app里的数据格式就如上文代码所书。 所有的订单信息都在in_app里。所以我们要找到最新成功的那条数据，就需要在这里面去找。 123注：1.消耗性的和其他的有区别，消耗性的下一次购买的，会覆盖上一次购买的，所以只有一条消耗性的订单信息，当然也是最新的。2.其他三种每次购买，都会生成新的订单信息，不会覆盖原来的，所以你购买多少次，上面就会显示多少条。 三、内购二次验证实际开发中具体做法 1.我们把收据信息传给服务器2.服务器自行处理所有的订单信息，返回一个成功与失败的状态给我们。所有的操作，后台都已经记录在案了，我们不再需要管。我们只需要知道，此次购买是否成功就行了。 结语：内购其实很简单，只是有时候不经意就会入坑，在此特意记录下困惑的地方，帮助自己深刻记忆，也希望帮助到其他遇到该问题的童鞋。]]></content>
      <categories>
        <category>iOS随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS导航栏设置背景图片]]></title>
    <url>%2F2018%2F01%2F22%2FiOS%E9%9A%8F%E7%AC%94%2FiOS%E5%AF%BC%E8%88%AA%E6%A0%8F%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[一、基础知识铺垫1.众所周知，导航栏设置背景图片有两个方法： 121.-setBackgroundImage:forBarMetrics:2.-setBackgroundImage:forBarPosition:barMetrics: 设置属性的话分别取：123456789101112131415forBarPosition ： UIBarPositionAnyUIBarPositionBottom ：官方解释shadow above the bar，注：除了这个枚举，其他使用都有效。UIBarPositionTopUIBarPositionTopAttachedbarMetrics ： UIBarMetricsDefault ： 我试过了除了这个默认属性，其他的使用了都无效。UIBarMetricsCompactUIBarMetricsDefaultPromptUIBarMetricsCompactPromptUIBarMetricsLandscapePhoneUIBarMetricsLandscapePhonePrompt注：一般情况下，只需要用1方法就行。 二、遇到问题但是，我就这么设置，然后遇到一个问题。UI给了我们有一张颜色渐变的背景图，尺寸为750*6。这张图分别用于：1.我们app中所有的按钮 2.首页的一张背景图 3.导航栏背景设置时，这张图默认是平铺的。设置按钮和UIImageview时都没问题，但是导航栏背景出问题了。 从图中可以看出，导航栏的颜色和用UIImageView设置的颜色并不相同，导航栏中颜色没有渐变。怎么办呢，我在想这是什么原因造成的。 我把设置导航栏的代码又检查了一遍，而且用了各种方法。1234比如 ： 1.将图片变成颜色给导航栏设置backgroundcolor 2.自己来画渐变色 3.设置导航栏的透明度 4.自定义UINavigaitonbar、、、等等 但是毫无效果，我细细琢磨，发现该导航栏上的颜色并没有出现渐变的颜色，而只取到了渐变颜色最左边的色值。有个朋友提醒我是不是导航栏设置颜色和其他控件设置颜色有什么不同。 最终我们猜想是导航栏可能是通过像素来平铺图片的。而出现上面问题的原因是，我这张背景图只有一张，没有@2x和@3x。在这里又涉及到关于@1x和@2x、@3x的意思和设置问题。12345知识小结：如果只有一张图，拖进Xcode中Assets.xcassets里，会自动放入@1x的选项框内。在iPhone4及后面的机型，都是取@2x和@3x的。那如果没有@2x和@3x，会默认选择@1x，而且尺寸和原图像素相同。如果有@2x和@3x，得到的尺寸是原图像素的一半。所以UI给我的图是750*6，我只取到了它的前一部分的色值。所以颜色没有渐变。 三、验证猜想为了验证猜想，我将图设置为320*6，用的是iPhone5s进行测试。 完美！此刻我的心情是激动的，为了进一步验证我的猜想，我创建了两张图@2x和@3x，图的尺寸分别为750 × 626和1125 × 939。为了方便观看效果，我用了另一张图来试验，用的是iPhone7测试。 问题完美解决。由于代码非常简单，这里给一张渐变的图，就放入下文了。资源文件： ——————————————————– 分割线 ————————————————–还有个东西忘记说了，就是设置设置导航栏底部阴影效果。系统有个方法是:setShadowImage 1[self.navigationController.navigationBar setShadowImage:[UIImage imageNamed:@&quot;timg&quot;]]; //这里的timg就是那张叶子图 然后得到了下面这样的效果。 初看时觉得这又是啥情况，它的UI结构其实很简单，如下图 由此可见，导航栏上所有的图片设置，都是按照像素来平铺的。 为了达到阴影效果，我在下面的UIImageView上加了一个view，设置view的阴影。12345678[self.navigationController.navigationBar setShadowImage:[UIImage new]]; //去除导航栏自带阴影UIView *view = [[UIView alloc] init];view.backgroundColor = [UIColor blackColor]; //这个随便设置什么颜色，切记不可设置为clearColorview.frame = CGRectMake(0, -1, [UIScreen mainScreen].bounds.size.width, 1);view.layer.shadowOpacity = 0.7; //不透明度view.layer.shadowOffset = CGSizeMake(0, 3); //偏移距离view.layer.shadowRadius = 5; //阴影半径[self.imgView addSubview: view]; 最终效果：]]></content>
      <categories>
        <category>iOS随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Github上如何创建ssh]]></title>
    <url>%2F2017%2F11%2F13%2FiOS%E9%9A%8F%E7%AC%94%2FGithub%E4%B8%8A%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAssh%2F</url>
    <content type="text"><![CDATA[1.创建本地ssh：操作环境（终端） ssh-keygen 输入密码 进入个人 / .ssh文件夹，打开id_rsa.pub，将里面内容拷贝。 2.在Github上创建ssh 1.进入Github官网，登录。点击右上角头像2.选择setting进入设置页面3.在左侧栏选择SSH and GPG keys，创建新的ssh4.Title随便填自己明白就行，Key就是将你本地创建的ssh复制过来。]]></content>
      <categories>
        <category>iOS随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何上传本地项目到GitHub远程仓库中]]></title>
    <url>%2F2017%2F11%2F13%2FiOS%E9%9A%8F%E7%AC%94%2F%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%88%B0GitHub%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[一、建立本地仓库：操作环境（终端）12341.cd到本地项目的文件夹路径下2.创建git: git init3.git add .4.git commit -m &apos;初始化想写啥写啥&apos; 二、添加远程仓库：操作环境（github上） 三、建立连接：操作环境（终端）1git remote add origin git@github.com:DaiYongTao/demo.git 其中`git@github.com:DaiYongTao/demo.git` 是图3中选择SSH时的地址 四、将本地仓库push到远程仓库：操作环境（终端）12git push -u origin master // 第一次推送master分支上所有的内容git push origin master // 推送最新修改 五、错误问题解决办法(很重要！！！注：在做这些步骤的前提是已经将ssh在本地创建好了。亦或者你的ssh已经过期了，你进行上面的最后一个步骤时会报错。所以需要检查ssh状态) 如果出现以下错误：12345Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 是因为你的ssh过期了，需要重新获取ssh，然后添加到github上去。 相关链接：Github上如何创建ssh]]></content>
      <categories>
        <category>iOS随笔</category>
      </categories>
  </entry>
</search>
